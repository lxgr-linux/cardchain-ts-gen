// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: cardchain/cardchain/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Coin } from "../../cosmos/base/v1beta1/coin";
import { CardRarity, cardRarityFromJSON, cardRarityToJSON } from "./card";
import { Response, responseFromJSON, responseToJSON } from "./council";
import { Outcome, outcomeFromJSON, outcomeToJSON } from "./match";
import { Params } from "./params";
import { SingleVote } from "./voting";

export const protobufPackage = "cardchain.cardchain";

/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParams {
  /**
   * authority is the address that controls the module (defaults to x/gov unless
   * overwritten).
   */
  authority: string;
  /** NOTE: All parameters must be supplied. */
  params: Params | undefined;
}

/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 */
export interface MsgUpdateParamsResponse {
}

export interface MsgUserCreate {
  creator: string;
  newUser: string;
  alias: string;
}

export interface MsgUserCreateResponse {
}

export interface MsgCardSchemeBuy {
  creator: string;
  bid: Coin | undefined;
}

export interface MsgCardSchemeBuyResponse {
  cardId: number;
}

export interface MsgCardSaveContent {
  creator: string;
  cardId: number;
  content: Uint8Array;
  notes: string;
  artist: string;
  balanceAnchor: boolean;
}

export interface MsgCardSaveContentResponse {
  airdropClaimed: boolean;
}

export interface MsgCardVote {
  creator: string;
  vote: SingleVote | undefined;
}

export interface MsgCardVoteResponse {
  airdropClaimed: boolean;
}

export interface MsgCardTransfer {
  creator: string;
  cardId: number;
  receiver: string;
}

export interface MsgCardTransferResponse {
}

export interface MsgCardDonate {
  creator: string;
  cardId: number;
  amount: Coin | undefined;
}

export interface MsgCardDonateResponse {
}

export interface MsgCardArtworkAdd {
  creator: string;
  cardId: number;
  image: Uint8Array;
  fullArt: boolean;
}

export interface MsgCardArtworkAddResponse {
}

export interface MsgCardArtistChange {
  creator: string;
  cardId: number;
  artist: string;
}

export interface MsgCardArtistChangeResponse {
}

export interface MsgCouncilRegister {
  creator: string;
}

export interface MsgCouncilRegisterResponse {
}

export interface MsgCouncilDeregister {
  creator: string;
}

export interface MsgCouncilDeregisterResponse {
}

export interface MsgMatchReport {
  creator: string;
  matchId: number;
  playedCardsA: number[];
  playedCardsB: number[];
  outcome: Outcome;
}

export interface MsgMatchReportResponse {
}

export interface MsgCouncilCreate {
  creator: string;
  cardId: number;
}

export interface MsgCouncilCreateResponse {
}

export interface MsgMatchReporterAppoint {
  authority: string;
  reporter: string;
}

export interface MsgMatchReporterAppointResponse {
}

export interface MsgSetCreate {
  creator: string;
  name: string;
  artist: string;
  storyWriter: string;
  contributors: string[];
}

export interface MsgSetCreateResponse {
}

export interface MsgSetCardAdd {
  creator: string;
  setId: number;
  cardId: number;
}

export interface MsgSetCardAddResponse {
}

export interface MsgSetCardRemove {
  creator: string;
  setId: number;
  cardId: number;
}

export interface MsgSetCardRemoveResponse {
}

export interface MsgSetContributorAdd {
  creator: string;
  setId: number;
  user: string;
}

export interface MsgSetContributorAddResponse {
}

export interface MsgSetContributorRemove {
  creator: string;
  setId: number;
  user: string;
}

export interface MsgSetContributorRemoveResponse {
}

export interface MsgSetFinalize {
  creator: string;
  setId: number;
}

export interface MsgSetFinalizeResponse {
}

export interface MsgSetArtworkAdd {
  creator: string;
  setId: number;
  image: Uint8Array;
}

export interface MsgSetArtworkAddResponse {
}

export interface MsgSetStoryAdd {
  creator: string;
  setId: number;
  story: string;
}

export interface MsgSetStoryAddResponse {
}

export interface MsgBoosterPackBuy {
  creator: string;
  setId: number;
}

export interface MsgBoosterPackBuyResponse {
  airdropClaimed: boolean;
}

export interface MsgSellOfferCreate {
  creator: string;
  cardId: number;
  price: Coin | undefined;
}

export interface MsgSellOfferCreateResponse {
}

export interface MsgSellOfferBuy {
  creator: string;
  sellOfferId: number;
}

export interface MsgSellOfferBuyResponse {
}

export interface MsgSellOfferRemove {
  creator: string;
  sellOfferId: number;
}

export interface MsgSellOfferRemoveResponse {
}

export interface MsgCardRaritySet {
  creator: string;
  cardId: number;
  setId: number;
  rarity: CardRarity;
}

export interface MsgCardRaritySetResponse {
}

export interface MsgCouncilResponseCommit {
  creator: string;
  councilId: number;
  response: string;
  suggestion: string;
}

export interface MsgCouncilResponseCommitResponse {
}

export interface MsgCouncilResponseReveal {
  creator: string;
  councilId: number;
  response: Response;
  secret: string;
}

export interface MsgCouncilResponseRevealResponse {
}

export interface MsgCouncilRestart {
  creator: string;
  councilId: number;
}

export interface MsgCouncilRestartResponse {
}

export interface MsgMatchConfirm {
  creator: string;
  matchId: number;
  outcome: Outcome;
  votedCards: SingleVote[];
}

export interface MsgMatchConfirmResponse {
}

export interface MsgProfileCardSet {
  creator: string;
  cardId: number;
}

export interface MsgProfileCardSetResponse {
}

export interface MsgProfileWebsiteSet {
  creator: string;
  website: string;
}

export interface MsgProfileWebsiteSetResponse {
}

export interface MsgProfileBioSet {
  creator: string;
  bio: string;
}

export interface MsgProfileBioSetResponse {
}

export interface MsgBoosterPackOpen {
  creator: string;
  boosterPackId: number;
}

export interface MsgBoosterPackOpenResponse {
  cardIds: number[];
}

export interface MsgBoosterPackTransfer {
  creator: string;
  boosterPackId: number;
  receiver: string;
}

export interface MsgBoosterPackTransferResponse {
}

export interface MsgSetStoryWriterSet {
  creator: string;
  setId: number;
  storyWriter: string;
}

export interface MsgSetStoryWriterSetResponse {
}

export interface MsgSetArtistSet {
  creator: string;
  setId: number;
  artist: string;
}

export interface MsgSetArtistSetResponse {
}

export interface MsgCardVoteMulti {
  creator: string;
  votes: SingleVote[];
}

export interface MsgCardVoteMultiResponse {
  airdropClaimed: boolean;
}

export interface MsgMatchOpen {
  creator: string;
  playerA: string;
  playerB: string;
  playerADeck: number[];
  playerBDeck: number[];
}

export interface MsgMatchOpenResponse {
  matchId: number;
}

export interface MsgSetNameSet {
  creator: string;
  setId: number;
  name: string;
}

export interface MsgSetNameSetResponse {
}

export interface MsgProfileAliasSet {
  creator: string;
  alias: string;
}

export interface MsgProfileAliasSetResponse {
}

export interface MsgEarlyAccessInvite {
  creator: string;
  user: string;
}

export interface MsgEarlyAccessInviteResponse {
}

export interface MsgZealyConnect {
  creator: string;
  zealyId: string;
}

export interface MsgZealyConnectResponse {
}

export interface MsgEncounterCreate {
  creator: string;
  name: string;
  drawlist: number[];
  parameters: { [key: string]: string };
  image: Uint8Array;
}

export interface MsgEncounterCreate_ParametersEntry {
  key: string;
  value: string;
}

export interface MsgEncounterCreateResponse {
}

export interface MsgEncounterDo {
  creator: string;
  encounterId: number;
  user: string;
}

export interface MsgEncounterDoResponse {
}

export interface MsgEncounterClose {
  creator: string;
  encounterId: number;
  user: string;
  won: boolean;
}

export interface MsgEncounterCloseResponse {
}

export interface MsgEarlyAccessDisinvite {
  creator: string;
  user: string;
}

export interface MsgEarlyAccessDisinviteResponse {
}

export interface MsgCardBan {
  authority: string;
  cardId: number;
}

export interface MsgCardBanResponse {
}

export interface MsgEarlyAccessGrant {
  authority: string;
  users: string[];
}

export interface MsgEarlyAccessGrantResponse {
}

export interface MsgSetActivate {
  authority: string;
  setId: number;
}

export interface MsgSetActivateResponse {
}

export interface MsgCardCopyrightClaim {
  authority: string;
  cardId: number;
}

export interface MsgCardCopyrightClaimResponse {
}

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(base?: I): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(object: I): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(base?: I): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(_: I): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgUserCreate(): MsgUserCreate {
  return { creator: "", newUser: "", alias: "" };
}

export const MsgUserCreate: MessageFns<MsgUserCreate> = {
  encode(message: MsgUserCreate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.newUser !== "") {
      writer.uint32(18).string(message.newUser);
    }
    if (message.alias !== "") {
      writer.uint32(26).string(message.alias);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUserCreate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUserCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newUser = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.alias = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUserCreate {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      newUser: isSet(object.newUser) ? globalThis.String(object.newUser) : "",
      alias: isSet(object.alias) ? globalThis.String(object.alias) : "",
    };
  },

  toJSON(message: MsgUserCreate): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.newUser !== "") {
      obj.newUser = message.newUser;
    }
    if (message.alias !== "") {
      obj.alias = message.alias;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUserCreate>, I>>(base?: I): MsgUserCreate {
    return MsgUserCreate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUserCreate>, I>>(object: I): MsgUserCreate {
    const message = createBaseMsgUserCreate();
    message.creator = object.creator ?? "";
    message.newUser = object.newUser ?? "";
    message.alias = object.alias ?? "";
    return message;
  },
};

function createBaseMsgUserCreateResponse(): MsgUserCreateResponse {
  return {};
}

export const MsgUserCreateResponse: MessageFns<MsgUserCreateResponse> = {
  encode(_: MsgUserCreateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUserCreateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUserCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUserCreateResponse {
    return {};
  },

  toJSON(_: MsgUserCreateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUserCreateResponse>, I>>(base?: I): MsgUserCreateResponse {
    return MsgUserCreateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUserCreateResponse>, I>>(_: I): MsgUserCreateResponse {
    const message = createBaseMsgUserCreateResponse();
    return message;
  },
};

function createBaseMsgCardSchemeBuy(): MsgCardSchemeBuy {
  return { creator: "", bid: undefined };
}

export const MsgCardSchemeBuy: MessageFns<MsgCardSchemeBuy> = {
  encode(message: MsgCardSchemeBuy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.bid !== undefined) {
      Coin.encode(message.bid, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardSchemeBuy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardSchemeBuy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bid = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCardSchemeBuy {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      bid: isSet(object.bid) ? Coin.fromJSON(object.bid) : undefined,
    };
  },

  toJSON(message: MsgCardSchemeBuy): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.bid !== undefined) {
      obj.bid = Coin.toJSON(message.bid);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardSchemeBuy>, I>>(base?: I): MsgCardSchemeBuy {
    return MsgCardSchemeBuy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardSchemeBuy>, I>>(object: I): MsgCardSchemeBuy {
    const message = createBaseMsgCardSchemeBuy();
    message.creator = object.creator ?? "";
    message.bid = (object.bid !== undefined && object.bid !== null) ? Coin.fromPartial(object.bid) : undefined;
    return message;
  },
};

function createBaseMsgCardSchemeBuyResponse(): MsgCardSchemeBuyResponse {
  return { cardId: 0 };
}

export const MsgCardSchemeBuyResponse: MessageFns<MsgCardSchemeBuyResponse> = {
  encode(message: MsgCardSchemeBuyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cardId !== 0) {
      writer.uint32(8).uint64(message.cardId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardSchemeBuyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardSchemeBuyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.cardId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCardSchemeBuyResponse {
    return { cardId: isSet(object.cardId) ? globalThis.Number(object.cardId) : 0 };
  },

  toJSON(message: MsgCardSchemeBuyResponse): unknown {
    const obj: any = {};
    if (message.cardId !== 0) {
      obj.cardId = Math.round(message.cardId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardSchemeBuyResponse>, I>>(base?: I): MsgCardSchemeBuyResponse {
    return MsgCardSchemeBuyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardSchemeBuyResponse>, I>>(object: I): MsgCardSchemeBuyResponse {
    const message = createBaseMsgCardSchemeBuyResponse();
    message.cardId = object.cardId ?? 0;
    return message;
  },
};

function createBaseMsgCardSaveContent(): MsgCardSaveContent {
  return { creator: "", cardId: 0, content: new Uint8Array(0), notes: "", artist: "", balanceAnchor: false };
}

export const MsgCardSaveContent: MessageFns<MsgCardSaveContent> = {
  encode(message: MsgCardSaveContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.cardId !== 0) {
      writer.uint32(16).uint64(message.cardId);
    }
    if (message.content.length !== 0) {
      writer.uint32(26).bytes(message.content);
    }
    if (message.notes !== "") {
      writer.uint32(34).string(message.notes);
    }
    if (message.artist !== "") {
      writer.uint32(42).string(message.artist);
    }
    if (message.balanceAnchor !== false) {
      writer.uint32(48).bool(message.balanceAnchor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardSaveContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardSaveContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cardId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.artist = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.balanceAnchor = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCardSaveContent {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      cardId: isSet(object.cardId) ? globalThis.Number(object.cardId) : 0,
      content: isSet(object.content) ? bytesFromBase64(object.content) : new Uint8Array(0),
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
      artist: isSet(object.artist) ? globalThis.String(object.artist) : "",
      balanceAnchor: isSet(object.balanceAnchor) ? globalThis.Boolean(object.balanceAnchor) : false,
    };
  },

  toJSON(message: MsgCardSaveContent): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.cardId !== 0) {
      obj.cardId = Math.round(message.cardId);
    }
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    if (message.notes !== "") {
      obj.notes = message.notes;
    }
    if (message.artist !== "") {
      obj.artist = message.artist;
    }
    if (message.balanceAnchor !== false) {
      obj.balanceAnchor = message.balanceAnchor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardSaveContent>, I>>(base?: I): MsgCardSaveContent {
    return MsgCardSaveContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardSaveContent>, I>>(object: I): MsgCardSaveContent {
    const message = createBaseMsgCardSaveContent();
    message.creator = object.creator ?? "";
    message.cardId = object.cardId ?? 0;
    message.content = object.content ?? new Uint8Array(0);
    message.notes = object.notes ?? "";
    message.artist = object.artist ?? "";
    message.balanceAnchor = object.balanceAnchor ?? false;
    return message;
  },
};

function createBaseMsgCardSaveContentResponse(): MsgCardSaveContentResponse {
  return { airdropClaimed: false };
}

export const MsgCardSaveContentResponse: MessageFns<MsgCardSaveContentResponse> = {
  encode(message: MsgCardSaveContentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.airdropClaimed !== false) {
      writer.uint32(8).bool(message.airdropClaimed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardSaveContentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardSaveContentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.airdropClaimed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCardSaveContentResponse {
    return { airdropClaimed: isSet(object.airdropClaimed) ? globalThis.Boolean(object.airdropClaimed) : false };
  },

  toJSON(message: MsgCardSaveContentResponse): unknown {
    const obj: any = {};
    if (message.airdropClaimed !== false) {
      obj.airdropClaimed = message.airdropClaimed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardSaveContentResponse>, I>>(base?: I): MsgCardSaveContentResponse {
    return MsgCardSaveContentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardSaveContentResponse>, I>>(object: I): MsgCardSaveContentResponse {
    const message = createBaseMsgCardSaveContentResponse();
    message.airdropClaimed = object.airdropClaimed ?? false;
    return message;
  },
};

function createBaseMsgCardVote(): MsgCardVote {
  return { creator: "", vote: undefined };
}

export const MsgCardVote: MessageFns<MsgCardVote> = {
  encode(message: MsgCardVote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.vote !== undefined) {
      SingleVote.encode(message.vote, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardVote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardVote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.vote = SingleVote.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCardVote {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      vote: isSet(object.vote) ? SingleVote.fromJSON(object.vote) : undefined,
    };
  },

  toJSON(message: MsgCardVote): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.vote !== undefined) {
      obj.vote = SingleVote.toJSON(message.vote);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardVote>, I>>(base?: I): MsgCardVote {
    return MsgCardVote.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardVote>, I>>(object: I): MsgCardVote {
    const message = createBaseMsgCardVote();
    message.creator = object.creator ?? "";
    message.vote = (object.vote !== undefined && object.vote !== null)
      ? SingleVote.fromPartial(object.vote)
      : undefined;
    return message;
  },
};

function createBaseMsgCardVoteResponse(): MsgCardVoteResponse {
  return { airdropClaimed: false };
}

export const MsgCardVoteResponse: MessageFns<MsgCardVoteResponse> = {
  encode(message: MsgCardVoteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.airdropClaimed !== false) {
      writer.uint32(8).bool(message.airdropClaimed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardVoteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardVoteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.airdropClaimed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCardVoteResponse {
    return { airdropClaimed: isSet(object.airdropClaimed) ? globalThis.Boolean(object.airdropClaimed) : false };
  },

  toJSON(message: MsgCardVoteResponse): unknown {
    const obj: any = {};
    if (message.airdropClaimed !== false) {
      obj.airdropClaimed = message.airdropClaimed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardVoteResponse>, I>>(base?: I): MsgCardVoteResponse {
    return MsgCardVoteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardVoteResponse>, I>>(object: I): MsgCardVoteResponse {
    const message = createBaseMsgCardVoteResponse();
    message.airdropClaimed = object.airdropClaimed ?? false;
    return message;
  },
};

function createBaseMsgCardTransfer(): MsgCardTransfer {
  return { creator: "", cardId: 0, receiver: "" };
}

export const MsgCardTransfer: MessageFns<MsgCardTransfer> = {
  encode(message: MsgCardTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.cardId !== 0) {
      writer.uint32(16).uint64(message.cardId);
    }
    if (message.receiver !== "") {
      writer.uint32(26).string(message.receiver);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cardId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.receiver = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCardTransfer {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      cardId: isSet(object.cardId) ? globalThis.Number(object.cardId) : 0,
      receiver: isSet(object.receiver) ? globalThis.String(object.receiver) : "",
    };
  },

  toJSON(message: MsgCardTransfer): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.cardId !== 0) {
      obj.cardId = Math.round(message.cardId);
    }
    if (message.receiver !== "") {
      obj.receiver = message.receiver;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardTransfer>, I>>(base?: I): MsgCardTransfer {
    return MsgCardTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardTransfer>, I>>(object: I): MsgCardTransfer {
    const message = createBaseMsgCardTransfer();
    message.creator = object.creator ?? "";
    message.cardId = object.cardId ?? 0;
    message.receiver = object.receiver ?? "";
    return message;
  },
};

function createBaseMsgCardTransferResponse(): MsgCardTransferResponse {
  return {};
}

export const MsgCardTransferResponse: MessageFns<MsgCardTransferResponse> = {
  encode(_: MsgCardTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCardTransferResponse {
    return {};
  },

  toJSON(_: MsgCardTransferResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardTransferResponse>, I>>(base?: I): MsgCardTransferResponse {
    return MsgCardTransferResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardTransferResponse>, I>>(_: I): MsgCardTransferResponse {
    const message = createBaseMsgCardTransferResponse();
    return message;
  },
};

function createBaseMsgCardDonate(): MsgCardDonate {
  return { creator: "", cardId: 0, amount: undefined };
}

export const MsgCardDonate: MessageFns<MsgCardDonate> = {
  encode(message: MsgCardDonate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.cardId !== 0) {
      writer.uint32(16).uint64(message.cardId);
    }
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardDonate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardDonate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cardId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCardDonate {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      cardId: isSet(object.cardId) ? globalThis.Number(object.cardId) : 0,
      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: MsgCardDonate): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.cardId !== 0) {
      obj.cardId = Math.round(message.cardId);
    }
    if (message.amount !== undefined) {
      obj.amount = Coin.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardDonate>, I>>(base?: I): MsgCardDonate {
    return MsgCardDonate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardDonate>, I>>(object: I): MsgCardDonate {
    const message = createBaseMsgCardDonate();
    message.creator = object.creator ?? "";
    message.cardId = object.cardId ?? 0;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseMsgCardDonateResponse(): MsgCardDonateResponse {
  return {};
}

export const MsgCardDonateResponse: MessageFns<MsgCardDonateResponse> = {
  encode(_: MsgCardDonateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardDonateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardDonateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCardDonateResponse {
    return {};
  },

  toJSON(_: MsgCardDonateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardDonateResponse>, I>>(base?: I): MsgCardDonateResponse {
    return MsgCardDonateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardDonateResponse>, I>>(_: I): MsgCardDonateResponse {
    const message = createBaseMsgCardDonateResponse();
    return message;
  },
};

function createBaseMsgCardArtworkAdd(): MsgCardArtworkAdd {
  return { creator: "", cardId: 0, image: new Uint8Array(0), fullArt: false };
}

export const MsgCardArtworkAdd: MessageFns<MsgCardArtworkAdd> = {
  encode(message: MsgCardArtworkAdd, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.cardId !== 0) {
      writer.uint32(16).uint64(message.cardId);
    }
    if (message.image.length !== 0) {
      writer.uint32(26).bytes(message.image);
    }
    if (message.fullArt !== false) {
      writer.uint32(32).bool(message.fullArt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardArtworkAdd {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardArtworkAdd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cardId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.image = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fullArt = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCardArtworkAdd {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      cardId: isSet(object.cardId) ? globalThis.Number(object.cardId) : 0,
      image: isSet(object.image) ? bytesFromBase64(object.image) : new Uint8Array(0),
      fullArt: isSet(object.fullArt) ? globalThis.Boolean(object.fullArt) : false,
    };
  },

  toJSON(message: MsgCardArtworkAdd): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.cardId !== 0) {
      obj.cardId = Math.round(message.cardId);
    }
    if (message.image.length !== 0) {
      obj.image = base64FromBytes(message.image);
    }
    if (message.fullArt !== false) {
      obj.fullArt = message.fullArt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardArtworkAdd>, I>>(base?: I): MsgCardArtworkAdd {
    return MsgCardArtworkAdd.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardArtworkAdd>, I>>(object: I): MsgCardArtworkAdd {
    const message = createBaseMsgCardArtworkAdd();
    message.creator = object.creator ?? "";
    message.cardId = object.cardId ?? 0;
    message.image = object.image ?? new Uint8Array(0);
    message.fullArt = object.fullArt ?? false;
    return message;
  },
};

function createBaseMsgCardArtworkAddResponse(): MsgCardArtworkAddResponse {
  return {};
}

export const MsgCardArtworkAddResponse: MessageFns<MsgCardArtworkAddResponse> = {
  encode(_: MsgCardArtworkAddResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardArtworkAddResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardArtworkAddResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCardArtworkAddResponse {
    return {};
  },

  toJSON(_: MsgCardArtworkAddResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardArtworkAddResponse>, I>>(base?: I): MsgCardArtworkAddResponse {
    return MsgCardArtworkAddResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardArtworkAddResponse>, I>>(_: I): MsgCardArtworkAddResponse {
    const message = createBaseMsgCardArtworkAddResponse();
    return message;
  },
};

function createBaseMsgCardArtistChange(): MsgCardArtistChange {
  return { creator: "", cardId: 0, artist: "" };
}

export const MsgCardArtistChange: MessageFns<MsgCardArtistChange> = {
  encode(message: MsgCardArtistChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.cardId !== 0) {
      writer.uint32(16).uint64(message.cardId);
    }
    if (message.artist !== "") {
      writer.uint32(26).string(message.artist);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardArtistChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardArtistChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cardId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.artist = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCardArtistChange {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      cardId: isSet(object.cardId) ? globalThis.Number(object.cardId) : 0,
      artist: isSet(object.artist) ? globalThis.String(object.artist) : "",
    };
  },

  toJSON(message: MsgCardArtistChange): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.cardId !== 0) {
      obj.cardId = Math.round(message.cardId);
    }
    if (message.artist !== "") {
      obj.artist = message.artist;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardArtistChange>, I>>(base?: I): MsgCardArtistChange {
    return MsgCardArtistChange.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardArtistChange>, I>>(object: I): MsgCardArtistChange {
    const message = createBaseMsgCardArtistChange();
    message.creator = object.creator ?? "";
    message.cardId = object.cardId ?? 0;
    message.artist = object.artist ?? "";
    return message;
  },
};

function createBaseMsgCardArtistChangeResponse(): MsgCardArtistChangeResponse {
  return {};
}

export const MsgCardArtistChangeResponse: MessageFns<MsgCardArtistChangeResponse> = {
  encode(_: MsgCardArtistChangeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardArtistChangeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardArtistChangeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCardArtistChangeResponse {
    return {};
  },

  toJSON(_: MsgCardArtistChangeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardArtistChangeResponse>, I>>(base?: I): MsgCardArtistChangeResponse {
    return MsgCardArtistChangeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardArtistChangeResponse>, I>>(_: I): MsgCardArtistChangeResponse {
    const message = createBaseMsgCardArtistChangeResponse();
    return message;
  },
};

function createBaseMsgCouncilRegister(): MsgCouncilRegister {
  return { creator: "" };
}

export const MsgCouncilRegister: MessageFns<MsgCouncilRegister> = {
  encode(message: MsgCouncilRegister, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCouncilRegister {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCouncilRegister();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCouncilRegister {
    return { creator: isSet(object.creator) ? globalThis.String(object.creator) : "" };
  },

  toJSON(message: MsgCouncilRegister): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCouncilRegister>, I>>(base?: I): MsgCouncilRegister {
    return MsgCouncilRegister.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCouncilRegister>, I>>(object: I): MsgCouncilRegister {
    const message = createBaseMsgCouncilRegister();
    message.creator = object.creator ?? "";
    return message;
  },
};

function createBaseMsgCouncilRegisterResponse(): MsgCouncilRegisterResponse {
  return {};
}

export const MsgCouncilRegisterResponse: MessageFns<MsgCouncilRegisterResponse> = {
  encode(_: MsgCouncilRegisterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCouncilRegisterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCouncilRegisterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCouncilRegisterResponse {
    return {};
  },

  toJSON(_: MsgCouncilRegisterResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCouncilRegisterResponse>, I>>(base?: I): MsgCouncilRegisterResponse {
    return MsgCouncilRegisterResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCouncilRegisterResponse>, I>>(_: I): MsgCouncilRegisterResponse {
    const message = createBaseMsgCouncilRegisterResponse();
    return message;
  },
};

function createBaseMsgCouncilDeregister(): MsgCouncilDeregister {
  return { creator: "" };
}

export const MsgCouncilDeregister: MessageFns<MsgCouncilDeregister> = {
  encode(message: MsgCouncilDeregister, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCouncilDeregister {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCouncilDeregister();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCouncilDeregister {
    return { creator: isSet(object.creator) ? globalThis.String(object.creator) : "" };
  },

  toJSON(message: MsgCouncilDeregister): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCouncilDeregister>, I>>(base?: I): MsgCouncilDeregister {
    return MsgCouncilDeregister.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCouncilDeregister>, I>>(object: I): MsgCouncilDeregister {
    const message = createBaseMsgCouncilDeregister();
    message.creator = object.creator ?? "";
    return message;
  },
};

function createBaseMsgCouncilDeregisterResponse(): MsgCouncilDeregisterResponse {
  return {};
}

export const MsgCouncilDeregisterResponse: MessageFns<MsgCouncilDeregisterResponse> = {
  encode(_: MsgCouncilDeregisterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCouncilDeregisterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCouncilDeregisterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCouncilDeregisterResponse {
    return {};
  },

  toJSON(_: MsgCouncilDeregisterResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCouncilDeregisterResponse>, I>>(base?: I): MsgCouncilDeregisterResponse {
    return MsgCouncilDeregisterResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCouncilDeregisterResponse>, I>>(_: I): MsgCouncilDeregisterResponse {
    const message = createBaseMsgCouncilDeregisterResponse();
    return message;
  },
};

function createBaseMsgMatchReport(): MsgMatchReport {
  return { creator: "", matchId: 0, playedCardsA: [], playedCardsB: [], outcome: 0 };
}

export const MsgMatchReport: MessageFns<MsgMatchReport> = {
  encode(message: MsgMatchReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.matchId !== 0) {
      writer.uint32(16).uint64(message.matchId);
    }
    writer.uint32(26).fork();
    for (const v of message.playedCardsA) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(34).fork();
    for (const v of message.playedCardsB) {
      writer.uint64(v);
    }
    writer.join();
    if (message.outcome !== 0) {
      writer.uint32(40).int32(message.outcome);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMatchReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMatchReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.matchId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.playedCardsA.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.playedCardsA.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag === 32) {
            message.playedCardsB.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.playedCardsB.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.outcome = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMatchReport {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      matchId: isSet(object.matchId) ? globalThis.Number(object.matchId) : 0,
      playedCardsA: globalThis.Array.isArray(object?.playedCardsA)
        ? object.playedCardsA.map((e: any) => globalThis.Number(e))
        : [],
      playedCardsB: globalThis.Array.isArray(object?.playedCardsB)
        ? object.playedCardsB.map((e: any) => globalThis.Number(e))
        : [],
      outcome: isSet(object.outcome) ? outcomeFromJSON(object.outcome) : 0,
    };
  },

  toJSON(message: MsgMatchReport): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.matchId !== 0) {
      obj.matchId = Math.round(message.matchId);
    }
    if (message.playedCardsA?.length) {
      obj.playedCardsA = message.playedCardsA.map((e) => Math.round(e));
    }
    if (message.playedCardsB?.length) {
      obj.playedCardsB = message.playedCardsB.map((e) => Math.round(e));
    }
    if (message.outcome !== 0) {
      obj.outcome = outcomeToJSON(message.outcome);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMatchReport>, I>>(base?: I): MsgMatchReport {
    return MsgMatchReport.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMatchReport>, I>>(object: I): MsgMatchReport {
    const message = createBaseMsgMatchReport();
    message.creator = object.creator ?? "";
    message.matchId = object.matchId ?? 0;
    message.playedCardsA = object.playedCardsA?.map((e) => e) || [];
    message.playedCardsB = object.playedCardsB?.map((e) => e) || [];
    message.outcome = object.outcome ?? 0;
    return message;
  },
};

function createBaseMsgMatchReportResponse(): MsgMatchReportResponse {
  return {};
}

export const MsgMatchReportResponse: MessageFns<MsgMatchReportResponse> = {
  encode(_: MsgMatchReportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMatchReportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMatchReportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgMatchReportResponse {
    return {};
  },

  toJSON(_: MsgMatchReportResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMatchReportResponse>, I>>(base?: I): MsgMatchReportResponse {
    return MsgMatchReportResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMatchReportResponse>, I>>(_: I): MsgMatchReportResponse {
    const message = createBaseMsgMatchReportResponse();
    return message;
  },
};

function createBaseMsgCouncilCreate(): MsgCouncilCreate {
  return { creator: "", cardId: 0 };
}

export const MsgCouncilCreate: MessageFns<MsgCouncilCreate> = {
  encode(message: MsgCouncilCreate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.cardId !== 0) {
      writer.uint32(16).uint64(message.cardId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCouncilCreate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCouncilCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cardId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCouncilCreate {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      cardId: isSet(object.cardId) ? globalThis.Number(object.cardId) : 0,
    };
  },

  toJSON(message: MsgCouncilCreate): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.cardId !== 0) {
      obj.cardId = Math.round(message.cardId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCouncilCreate>, I>>(base?: I): MsgCouncilCreate {
    return MsgCouncilCreate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCouncilCreate>, I>>(object: I): MsgCouncilCreate {
    const message = createBaseMsgCouncilCreate();
    message.creator = object.creator ?? "";
    message.cardId = object.cardId ?? 0;
    return message;
  },
};

function createBaseMsgCouncilCreateResponse(): MsgCouncilCreateResponse {
  return {};
}

export const MsgCouncilCreateResponse: MessageFns<MsgCouncilCreateResponse> = {
  encode(_: MsgCouncilCreateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCouncilCreateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCouncilCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCouncilCreateResponse {
    return {};
  },

  toJSON(_: MsgCouncilCreateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCouncilCreateResponse>, I>>(base?: I): MsgCouncilCreateResponse {
    return MsgCouncilCreateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCouncilCreateResponse>, I>>(_: I): MsgCouncilCreateResponse {
    const message = createBaseMsgCouncilCreateResponse();
    return message;
  },
};

function createBaseMsgMatchReporterAppoint(): MsgMatchReporterAppoint {
  return { authority: "", reporter: "" };
}

export const MsgMatchReporterAppoint: MessageFns<MsgMatchReporterAppoint> = {
  encode(message: MsgMatchReporterAppoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.reporter !== "") {
      writer.uint32(18).string(message.reporter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMatchReporterAppoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMatchReporterAppoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reporter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMatchReporterAppoint {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      reporter: isSet(object.reporter) ? globalThis.String(object.reporter) : "",
    };
  },

  toJSON(message: MsgMatchReporterAppoint): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.reporter !== "") {
      obj.reporter = message.reporter;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMatchReporterAppoint>, I>>(base?: I): MsgMatchReporterAppoint {
    return MsgMatchReporterAppoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMatchReporterAppoint>, I>>(object: I): MsgMatchReporterAppoint {
    const message = createBaseMsgMatchReporterAppoint();
    message.authority = object.authority ?? "";
    message.reporter = object.reporter ?? "";
    return message;
  },
};

function createBaseMsgMatchReporterAppointResponse(): MsgMatchReporterAppointResponse {
  return {};
}

export const MsgMatchReporterAppointResponse: MessageFns<MsgMatchReporterAppointResponse> = {
  encode(_: MsgMatchReporterAppointResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMatchReporterAppointResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMatchReporterAppointResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgMatchReporterAppointResponse {
    return {};
  },

  toJSON(_: MsgMatchReporterAppointResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMatchReporterAppointResponse>, I>>(base?: I): MsgMatchReporterAppointResponse {
    return MsgMatchReporterAppointResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMatchReporterAppointResponse>, I>>(_: I): MsgMatchReporterAppointResponse {
    const message = createBaseMsgMatchReporterAppointResponse();
    return message;
  },
};

function createBaseMsgSetCreate(): MsgSetCreate {
  return { creator: "", name: "", artist: "", storyWriter: "", contributors: [] };
}

export const MsgSetCreate: MessageFns<MsgSetCreate> = {
  encode(message: MsgSetCreate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.artist !== "") {
      writer.uint32(26).string(message.artist);
    }
    if (message.storyWriter !== "") {
      writer.uint32(34).string(message.storyWriter);
    }
    for (const v of message.contributors) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetCreate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.artist = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.storyWriter = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contributors.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetCreate {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      artist: isSet(object.artist) ? globalThis.String(object.artist) : "",
      storyWriter: isSet(object.storyWriter) ? globalThis.String(object.storyWriter) : "",
      contributors: globalThis.Array.isArray(object?.contributors)
        ? object.contributors.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MsgSetCreate): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.artist !== "") {
      obj.artist = message.artist;
    }
    if (message.storyWriter !== "") {
      obj.storyWriter = message.storyWriter;
    }
    if (message.contributors?.length) {
      obj.contributors = message.contributors;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetCreate>, I>>(base?: I): MsgSetCreate {
    return MsgSetCreate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetCreate>, I>>(object: I): MsgSetCreate {
    const message = createBaseMsgSetCreate();
    message.creator = object.creator ?? "";
    message.name = object.name ?? "";
    message.artist = object.artist ?? "";
    message.storyWriter = object.storyWriter ?? "";
    message.contributors = object.contributors?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgSetCreateResponse(): MsgSetCreateResponse {
  return {};
}

export const MsgSetCreateResponse: MessageFns<MsgSetCreateResponse> = {
  encode(_: MsgSetCreateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetCreateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetCreateResponse {
    return {};
  },

  toJSON(_: MsgSetCreateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetCreateResponse>, I>>(base?: I): MsgSetCreateResponse {
    return MsgSetCreateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetCreateResponse>, I>>(_: I): MsgSetCreateResponse {
    const message = createBaseMsgSetCreateResponse();
    return message;
  },
};

function createBaseMsgSetCardAdd(): MsgSetCardAdd {
  return { creator: "", setId: 0, cardId: 0 };
}

export const MsgSetCardAdd: MessageFns<MsgSetCardAdd> = {
  encode(message: MsgSetCardAdd, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.setId !== 0) {
      writer.uint32(16).uint64(message.setId);
    }
    if (message.cardId !== 0) {
      writer.uint32(24).uint64(message.cardId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetCardAdd {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetCardAdd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.setId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.cardId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetCardAdd {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      setId: isSet(object.setId) ? globalThis.Number(object.setId) : 0,
      cardId: isSet(object.cardId) ? globalThis.Number(object.cardId) : 0,
    };
  },

  toJSON(message: MsgSetCardAdd): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.setId !== 0) {
      obj.setId = Math.round(message.setId);
    }
    if (message.cardId !== 0) {
      obj.cardId = Math.round(message.cardId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetCardAdd>, I>>(base?: I): MsgSetCardAdd {
    return MsgSetCardAdd.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetCardAdd>, I>>(object: I): MsgSetCardAdd {
    const message = createBaseMsgSetCardAdd();
    message.creator = object.creator ?? "";
    message.setId = object.setId ?? 0;
    message.cardId = object.cardId ?? 0;
    return message;
  },
};

function createBaseMsgSetCardAddResponse(): MsgSetCardAddResponse {
  return {};
}

export const MsgSetCardAddResponse: MessageFns<MsgSetCardAddResponse> = {
  encode(_: MsgSetCardAddResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetCardAddResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetCardAddResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetCardAddResponse {
    return {};
  },

  toJSON(_: MsgSetCardAddResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetCardAddResponse>, I>>(base?: I): MsgSetCardAddResponse {
    return MsgSetCardAddResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetCardAddResponse>, I>>(_: I): MsgSetCardAddResponse {
    const message = createBaseMsgSetCardAddResponse();
    return message;
  },
};

function createBaseMsgSetCardRemove(): MsgSetCardRemove {
  return { creator: "", setId: 0, cardId: 0 };
}

export const MsgSetCardRemove: MessageFns<MsgSetCardRemove> = {
  encode(message: MsgSetCardRemove, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.setId !== 0) {
      writer.uint32(16).uint64(message.setId);
    }
    if (message.cardId !== 0) {
      writer.uint32(24).uint64(message.cardId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetCardRemove {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetCardRemove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.setId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.cardId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetCardRemove {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      setId: isSet(object.setId) ? globalThis.Number(object.setId) : 0,
      cardId: isSet(object.cardId) ? globalThis.Number(object.cardId) : 0,
    };
  },

  toJSON(message: MsgSetCardRemove): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.setId !== 0) {
      obj.setId = Math.round(message.setId);
    }
    if (message.cardId !== 0) {
      obj.cardId = Math.round(message.cardId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetCardRemove>, I>>(base?: I): MsgSetCardRemove {
    return MsgSetCardRemove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetCardRemove>, I>>(object: I): MsgSetCardRemove {
    const message = createBaseMsgSetCardRemove();
    message.creator = object.creator ?? "";
    message.setId = object.setId ?? 0;
    message.cardId = object.cardId ?? 0;
    return message;
  },
};

function createBaseMsgSetCardRemoveResponse(): MsgSetCardRemoveResponse {
  return {};
}

export const MsgSetCardRemoveResponse: MessageFns<MsgSetCardRemoveResponse> = {
  encode(_: MsgSetCardRemoveResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetCardRemoveResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetCardRemoveResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetCardRemoveResponse {
    return {};
  },

  toJSON(_: MsgSetCardRemoveResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetCardRemoveResponse>, I>>(base?: I): MsgSetCardRemoveResponse {
    return MsgSetCardRemoveResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetCardRemoveResponse>, I>>(_: I): MsgSetCardRemoveResponse {
    const message = createBaseMsgSetCardRemoveResponse();
    return message;
  },
};

function createBaseMsgSetContributorAdd(): MsgSetContributorAdd {
  return { creator: "", setId: 0, user: "" };
}

export const MsgSetContributorAdd: MessageFns<MsgSetContributorAdd> = {
  encode(message: MsgSetContributorAdd, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.setId !== 0) {
      writer.uint32(16).uint64(message.setId);
    }
    if (message.user !== "") {
      writer.uint32(26).string(message.user);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetContributorAdd {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetContributorAdd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.setId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetContributorAdd {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      setId: isSet(object.setId) ? globalThis.Number(object.setId) : 0,
      user: isSet(object.user) ? globalThis.String(object.user) : "",
    };
  },

  toJSON(message: MsgSetContributorAdd): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.setId !== 0) {
      obj.setId = Math.round(message.setId);
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetContributorAdd>, I>>(base?: I): MsgSetContributorAdd {
    return MsgSetContributorAdd.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetContributorAdd>, I>>(object: I): MsgSetContributorAdd {
    const message = createBaseMsgSetContributorAdd();
    message.creator = object.creator ?? "";
    message.setId = object.setId ?? 0;
    message.user = object.user ?? "";
    return message;
  },
};

function createBaseMsgSetContributorAddResponse(): MsgSetContributorAddResponse {
  return {};
}

export const MsgSetContributorAddResponse: MessageFns<MsgSetContributorAddResponse> = {
  encode(_: MsgSetContributorAddResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetContributorAddResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetContributorAddResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetContributorAddResponse {
    return {};
  },

  toJSON(_: MsgSetContributorAddResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetContributorAddResponse>, I>>(base?: I): MsgSetContributorAddResponse {
    return MsgSetContributorAddResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetContributorAddResponse>, I>>(_: I): MsgSetContributorAddResponse {
    const message = createBaseMsgSetContributorAddResponse();
    return message;
  },
};

function createBaseMsgSetContributorRemove(): MsgSetContributorRemove {
  return { creator: "", setId: 0, user: "" };
}

export const MsgSetContributorRemove: MessageFns<MsgSetContributorRemove> = {
  encode(message: MsgSetContributorRemove, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.setId !== 0) {
      writer.uint32(16).uint64(message.setId);
    }
    if (message.user !== "") {
      writer.uint32(26).string(message.user);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetContributorRemove {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetContributorRemove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.setId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetContributorRemove {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      setId: isSet(object.setId) ? globalThis.Number(object.setId) : 0,
      user: isSet(object.user) ? globalThis.String(object.user) : "",
    };
  },

  toJSON(message: MsgSetContributorRemove): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.setId !== 0) {
      obj.setId = Math.round(message.setId);
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetContributorRemove>, I>>(base?: I): MsgSetContributorRemove {
    return MsgSetContributorRemove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetContributorRemove>, I>>(object: I): MsgSetContributorRemove {
    const message = createBaseMsgSetContributorRemove();
    message.creator = object.creator ?? "";
    message.setId = object.setId ?? 0;
    message.user = object.user ?? "";
    return message;
  },
};

function createBaseMsgSetContributorRemoveResponse(): MsgSetContributorRemoveResponse {
  return {};
}

export const MsgSetContributorRemoveResponse: MessageFns<MsgSetContributorRemoveResponse> = {
  encode(_: MsgSetContributorRemoveResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetContributorRemoveResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetContributorRemoveResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetContributorRemoveResponse {
    return {};
  },

  toJSON(_: MsgSetContributorRemoveResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetContributorRemoveResponse>, I>>(base?: I): MsgSetContributorRemoveResponse {
    return MsgSetContributorRemoveResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetContributorRemoveResponse>, I>>(_: I): MsgSetContributorRemoveResponse {
    const message = createBaseMsgSetContributorRemoveResponse();
    return message;
  },
};

function createBaseMsgSetFinalize(): MsgSetFinalize {
  return { creator: "", setId: 0 };
}

export const MsgSetFinalize: MessageFns<MsgSetFinalize> = {
  encode(message: MsgSetFinalize, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.setId !== 0) {
      writer.uint32(16).uint64(message.setId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetFinalize {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetFinalize();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.setId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetFinalize {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      setId: isSet(object.setId) ? globalThis.Number(object.setId) : 0,
    };
  },

  toJSON(message: MsgSetFinalize): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.setId !== 0) {
      obj.setId = Math.round(message.setId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetFinalize>, I>>(base?: I): MsgSetFinalize {
    return MsgSetFinalize.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetFinalize>, I>>(object: I): MsgSetFinalize {
    const message = createBaseMsgSetFinalize();
    message.creator = object.creator ?? "";
    message.setId = object.setId ?? 0;
    return message;
  },
};

function createBaseMsgSetFinalizeResponse(): MsgSetFinalizeResponse {
  return {};
}

export const MsgSetFinalizeResponse: MessageFns<MsgSetFinalizeResponse> = {
  encode(_: MsgSetFinalizeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetFinalizeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetFinalizeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetFinalizeResponse {
    return {};
  },

  toJSON(_: MsgSetFinalizeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetFinalizeResponse>, I>>(base?: I): MsgSetFinalizeResponse {
    return MsgSetFinalizeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetFinalizeResponse>, I>>(_: I): MsgSetFinalizeResponse {
    const message = createBaseMsgSetFinalizeResponse();
    return message;
  },
};

function createBaseMsgSetArtworkAdd(): MsgSetArtworkAdd {
  return { creator: "", setId: 0, image: new Uint8Array(0) };
}

export const MsgSetArtworkAdd: MessageFns<MsgSetArtworkAdd> = {
  encode(message: MsgSetArtworkAdd, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.setId !== 0) {
      writer.uint32(16).uint64(message.setId);
    }
    if (message.image.length !== 0) {
      writer.uint32(26).bytes(message.image);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetArtworkAdd {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetArtworkAdd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.setId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.image = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetArtworkAdd {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      setId: isSet(object.setId) ? globalThis.Number(object.setId) : 0,
      image: isSet(object.image) ? bytesFromBase64(object.image) : new Uint8Array(0),
    };
  },

  toJSON(message: MsgSetArtworkAdd): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.setId !== 0) {
      obj.setId = Math.round(message.setId);
    }
    if (message.image.length !== 0) {
      obj.image = base64FromBytes(message.image);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetArtworkAdd>, I>>(base?: I): MsgSetArtworkAdd {
    return MsgSetArtworkAdd.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetArtworkAdd>, I>>(object: I): MsgSetArtworkAdd {
    const message = createBaseMsgSetArtworkAdd();
    message.creator = object.creator ?? "";
    message.setId = object.setId ?? 0;
    message.image = object.image ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgSetArtworkAddResponse(): MsgSetArtworkAddResponse {
  return {};
}

export const MsgSetArtworkAddResponse: MessageFns<MsgSetArtworkAddResponse> = {
  encode(_: MsgSetArtworkAddResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetArtworkAddResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetArtworkAddResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetArtworkAddResponse {
    return {};
  },

  toJSON(_: MsgSetArtworkAddResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetArtworkAddResponse>, I>>(base?: I): MsgSetArtworkAddResponse {
    return MsgSetArtworkAddResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetArtworkAddResponse>, I>>(_: I): MsgSetArtworkAddResponse {
    const message = createBaseMsgSetArtworkAddResponse();
    return message;
  },
};

function createBaseMsgSetStoryAdd(): MsgSetStoryAdd {
  return { creator: "", setId: 0, story: "" };
}

export const MsgSetStoryAdd: MessageFns<MsgSetStoryAdd> = {
  encode(message: MsgSetStoryAdd, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.setId !== 0) {
      writer.uint32(16).uint64(message.setId);
    }
    if (message.story !== "") {
      writer.uint32(26).string(message.story);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetStoryAdd {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetStoryAdd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.setId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.story = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetStoryAdd {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      setId: isSet(object.setId) ? globalThis.Number(object.setId) : 0,
      story: isSet(object.story) ? globalThis.String(object.story) : "",
    };
  },

  toJSON(message: MsgSetStoryAdd): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.setId !== 0) {
      obj.setId = Math.round(message.setId);
    }
    if (message.story !== "") {
      obj.story = message.story;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetStoryAdd>, I>>(base?: I): MsgSetStoryAdd {
    return MsgSetStoryAdd.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetStoryAdd>, I>>(object: I): MsgSetStoryAdd {
    const message = createBaseMsgSetStoryAdd();
    message.creator = object.creator ?? "";
    message.setId = object.setId ?? 0;
    message.story = object.story ?? "";
    return message;
  },
};

function createBaseMsgSetStoryAddResponse(): MsgSetStoryAddResponse {
  return {};
}

export const MsgSetStoryAddResponse: MessageFns<MsgSetStoryAddResponse> = {
  encode(_: MsgSetStoryAddResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetStoryAddResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetStoryAddResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetStoryAddResponse {
    return {};
  },

  toJSON(_: MsgSetStoryAddResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetStoryAddResponse>, I>>(base?: I): MsgSetStoryAddResponse {
    return MsgSetStoryAddResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetStoryAddResponse>, I>>(_: I): MsgSetStoryAddResponse {
    const message = createBaseMsgSetStoryAddResponse();
    return message;
  },
};

function createBaseMsgBoosterPackBuy(): MsgBoosterPackBuy {
  return { creator: "", setId: 0 };
}

export const MsgBoosterPackBuy: MessageFns<MsgBoosterPackBuy> = {
  encode(message: MsgBoosterPackBuy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.setId !== 0) {
      writer.uint32(16).uint64(message.setId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBoosterPackBuy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBoosterPackBuy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.setId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBoosterPackBuy {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      setId: isSet(object.setId) ? globalThis.Number(object.setId) : 0,
    };
  },

  toJSON(message: MsgBoosterPackBuy): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.setId !== 0) {
      obj.setId = Math.round(message.setId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBoosterPackBuy>, I>>(base?: I): MsgBoosterPackBuy {
    return MsgBoosterPackBuy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBoosterPackBuy>, I>>(object: I): MsgBoosterPackBuy {
    const message = createBaseMsgBoosterPackBuy();
    message.creator = object.creator ?? "";
    message.setId = object.setId ?? 0;
    return message;
  },
};

function createBaseMsgBoosterPackBuyResponse(): MsgBoosterPackBuyResponse {
  return { airdropClaimed: false };
}

export const MsgBoosterPackBuyResponse: MessageFns<MsgBoosterPackBuyResponse> = {
  encode(message: MsgBoosterPackBuyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.airdropClaimed !== false) {
      writer.uint32(8).bool(message.airdropClaimed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBoosterPackBuyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBoosterPackBuyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.airdropClaimed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBoosterPackBuyResponse {
    return { airdropClaimed: isSet(object.airdropClaimed) ? globalThis.Boolean(object.airdropClaimed) : false };
  },

  toJSON(message: MsgBoosterPackBuyResponse): unknown {
    const obj: any = {};
    if (message.airdropClaimed !== false) {
      obj.airdropClaimed = message.airdropClaimed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBoosterPackBuyResponse>, I>>(base?: I): MsgBoosterPackBuyResponse {
    return MsgBoosterPackBuyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBoosterPackBuyResponse>, I>>(object: I): MsgBoosterPackBuyResponse {
    const message = createBaseMsgBoosterPackBuyResponse();
    message.airdropClaimed = object.airdropClaimed ?? false;
    return message;
  },
};

function createBaseMsgSellOfferCreate(): MsgSellOfferCreate {
  return { creator: "", cardId: 0, price: undefined };
}

export const MsgSellOfferCreate: MessageFns<MsgSellOfferCreate> = {
  encode(message: MsgSellOfferCreate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.cardId !== 0) {
      writer.uint32(16).uint64(message.cardId);
    }
    if (message.price !== undefined) {
      Coin.encode(message.price, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSellOfferCreate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSellOfferCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cardId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.price = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSellOfferCreate {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      cardId: isSet(object.cardId) ? globalThis.Number(object.cardId) : 0,
      price: isSet(object.price) ? Coin.fromJSON(object.price) : undefined,
    };
  },

  toJSON(message: MsgSellOfferCreate): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.cardId !== 0) {
      obj.cardId = Math.round(message.cardId);
    }
    if (message.price !== undefined) {
      obj.price = Coin.toJSON(message.price);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSellOfferCreate>, I>>(base?: I): MsgSellOfferCreate {
    return MsgSellOfferCreate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSellOfferCreate>, I>>(object: I): MsgSellOfferCreate {
    const message = createBaseMsgSellOfferCreate();
    message.creator = object.creator ?? "";
    message.cardId = object.cardId ?? 0;
    message.price = (object.price !== undefined && object.price !== null) ? Coin.fromPartial(object.price) : undefined;
    return message;
  },
};

function createBaseMsgSellOfferCreateResponse(): MsgSellOfferCreateResponse {
  return {};
}

export const MsgSellOfferCreateResponse: MessageFns<MsgSellOfferCreateResponse> = {
  encode(_: MsgSellOfferCreateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSellOfferCreateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSellOfferCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSellOfferCreateResponse {
    return {};
  },

  toJSON(_: MsgSellOfferCreateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSellOfferCreateResponse>, I>>(base?: I): MsgSellOfferCreateResponse {
    return MsgSellOfferCreateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSellOfferCreateResponse>, I>>(_: I): MsgSellOfferCreateResponse {
    const message = createBaseMsgSellOfferCreateResponse();
    return message;
  },
};

function createBaseMsgSellOfferBuy(): MsgSellOfferBuy {
  return { creator: "", sellOfferId: 0 };
}

export const MsgSellOfferBuy: MessageFns<MsgSellOfferBuy> = {
  encode(message: MsgSellOfferBuy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.sellOfferId !== 0) {
      writer.uint32(16).uint64(message.sellOfferId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSellOfferBuy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSellOfferBuy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sellOfferId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSellOfferBuy {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      sellOfferId: isSet(object.sellOfferId) ? globalThis.Number(object.sellOfferId) : 0,
    };
  },

  toJSON(message: MsgSellOfferBuy): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.sellOfferId !== 0) {
      obj.sellOfferId = Math.round(message.sellOfferId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSellOfferBuy>, I>>(base?: I): MsgSellOfferBuy {
    return MsgSellOfferBuy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSellOfferBuy>, I>>(object: I): MsgSellOfferBuy {
    const message = createBaseMsgSellOfferBuy();
    message.creator = object.creator ?? "";
    message.sellOfferId = object.sellOfferId ?? 0;
    return message;
  },
};

function createBaseMsgSellOfferBuyResponse(): MsgSellOfferBuyResponse {
  return {};
}

export const MsgSellOfferBuyResponse: MessageFns<MsgSellOfferBuyResponse> = {
  encode(_: MsgSellOfferBuyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSellOfferBuyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSellOfferBuyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSellOfferBuyResponse {
    return {};
  },

  toJSON(_: MsgSellOfferBuyResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSellOfferBuyResponse>, I>>(base?: I): MsgSellOfferBuyResponse {
    return MsgSellOfferBuyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSellOfferBuyResponse>, I>>(_: I): MsgSellOfferBuyResponse {
    const message = createBaseMsgSellOfferBuyResponse();
    return message;
  },
};

function createBaseMsgSellOfferRemove(): MsgSellOfferRemove {
  return { creator: "", sellOfferId: 0 };
}

export const MsgSellOfferRemove: MessageFns<MsgSellOfferRemove> = {
  encode(message: MsgSellOfferRemove, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.sellOfferId !== 0) {
      writer.uint32(16).uint64(message.sellOfferId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSellOfferRemove {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSellOfferRemove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sellOfferId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSellOfferRemove {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      sellOfferId: isSet(object.sellOfferId) ? globalThis.Number(object.sellOfferId) : 0,
    };
  },

  toJSON(message: MsgSellOfferRemove): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.sellOfferId !== 0) {
      obj.sellOfferId = Math.round(message.sellOfferId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSellOfferRemove>, I>>(base?: I): MsgSellOfferRemove {
    return MsgSellOfferRemove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSellOfferRemove>, I>>(object: I): MsgSellOfferRemove {
    const message = createBaseMsgSellOfferRemove();
    message.creator = object.creator ?? "";
    message.sellOfferId = object.sellOfferId ?? 0;
    return message;
  },
};

function createBaseMsgSellOfferRemoveResponse(): MsgSellOfferRemoveResponse {
  return {};
}

export const MsgSellOfferRemoveResponse: MessageFns<MsgSellOfferRemoveResponse> = {
  encode(_: MsgSellOfferRemoveResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSellOfferRemoveResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSellOfferRemoveResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSellOfferRemoveResponse {
    return {};
  },

  toJSON(_: MsgSellOfferRemoveResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSellOfferRemoveResponse>, I>>(base?: I): MsgSellOfferRemoveResponse {
    return MsgSellOfferRemoveResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSellOfferRemoveResponse>, I>>(_: I): MsgSellOfferRemoveResponse {
    const message = createBaseMsgSellOfferRemoveResponse();
    return message;
  },
};

function createBaseMsgCardRaritySet(): MsgCardRaritySet {
  return { creator: "", cardId: 0, setId: 0, rarity: 0 };
}

export const MsgCardRaritySet: MessageFns<MsgCardRaritySet> = {
  encode(message: MsgCardRaritySet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.cardId !== 0) {
      writer.uint32(16).uint64(message.cardId);
    }
    if (message.setId !== 0) {
      writer.uint32(24).uint64(message.setId);
    }
    if (message.rarity !== 0) {
      writer.uint32(32).int32(message.rarity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardRaritySet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardRaritySet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cardId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.setId = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rarity = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCardRaritySet {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      cardId: isSet(object.cardId) ? globalThis.Number(object.cardId) : 0,
      setId: isSet(object.setId) ? globalThis.Number(object.setId) : 0,
      rarity: isSet(object.rarity) ? cardRarityFromJSON(object.rarity) : 0,
    };
  },

  toJSON(message: MsgCardRaritySet): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.cardId !== 0) {
      obj.cardId = Math.round(message.cardId);
    }
    if (message.setId !== 0) {
      obj.setId = Math.round(message.setId);
    }
    if (message.rarity !== 0) {
      obj.rarity = cardRarityToJSON(message.rarity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardRaritySet>, I>>(base?: I): MsgCardRaritySet {
    return MsgCardRaritySet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardRaritySet>, I>>(object: I): MsgCardRaritySet {
    const message = createBaseMsgCardRaritySet();
    message.creator = object.creator ?? "";
    message.cardId = object.cardId ?? 0;
    message.setId = object.setId ?? 0;
    message.rarity = object.rarity ?? 0;
    return message;
  },
};

function createBaseMsgCardRaritySetResponse(): MsgCardRaritySetResponse {
  return {};
}

export const MsgCardRaritySetResponse: MessageFns<MsgCardRaritySetResponse> = {
  encode(_: MsgCardRaritySetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardRaritySetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardRaritySetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCardRaritySetResponse {
    return {};
  },

  toJSON(_: MsgCardRaritySetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardRaritySetResponse>, I>>(base?: I): MsgCardRaritySetResponse {
    return MsgCardRaritySetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardRaritySetResponse>, I>>(_: I): MsgCardRaritySetResponse {
    const message = createBaseMsgCardRaritySetResponse();
    return message;
  },
};

function createBaseMsgCouncilResponseCommit(): MsgCouncilResponseCommit {
  return { creator: "", councilId: 0, response: "", suggestion: "" };
}

export const MsgCouncilResponseCommit: MessageFns<MsgCouncilResponseCommit> = {
  encode(message: MsgCouncilResponseCommit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.councilId !== 0) {
      writer.uint32(16).uint64(message.councilId);
    }
    if (message.response !== "") {
      writer.uint32(26).string(message.response);
    }
    if (message.suggestion !== "") {
      writer.uint32(34).string(message.suggestion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCouncilResponseCommit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCouncilResponseCommit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.councilId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.response = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.suggestion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCouncilResponseCommit {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      councilId: isSet(object.councilId) ? globalThis.Number(object.councilId) : 0,
      response: isSet(object.response) ? globalThis.String(object.response) : "",
      suggestion: isSet(object.suggestion) ? globalThis.String(object.suggestion) : "",
    };
  },

  toJSON(message: MsgCouncilResponseCommit): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.councilId !== 0) {
      obj.councilId = Math.round(message.councilId);
    }
    if (message.response !== "") {
      obj.response = message.response;
    }
    if (message.suggestion !== "") {
      obj.suggestion = message.suggestion;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCouncilResponseCommit>, I>>(base?: I): MsgCouncilResponseCommit {
    return MsgCouncilResponseCommit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCouncilResponseCommit>, I>>(object: I): MsgCouncilResponseCommit {
    const message = createBaseMsgCouncilResponseCommit();
    message.creator = object.creator ?? "";
    message.councilId = object.councilId ?? 0;
    message.response = object.response ?? "";
    message.suggestion = object.suggestion ?? "";
    return message;
  },
};

function createBaseMsgCouncilResponseCommitResponse(): MsgCouncilResponseCommitResponse {
  return {};
}

export const MsgCouncilResponseCommitResponse: MessageFns<MsgCouncilResponseCommitResponse> = {
  encode(_: MsgCouncilResponseCommitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCouncilResponseCommitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCouncilResponseCommitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCouncilResponseCommitResponse {
    return {};
  },

  toJSON(_: MsgCouncilResponseCommitResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCouncilResponseCommitResponse>, I>>(
    base?: I,
  ): MsgCouncilResponseCommitResponse {
    return MsgCouncilResponseCommitResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCouncilResponseCommitResponse>, I>>(
    _: I,
  ): MsgCouncilResponseCommitResponse {
    const message = createBaseMsgCouncilResponseCommitResponse();
    return message;
  },
};

function createBaseMsgCouncilResponseReveal(): MsgCouncilResponseReveal {
  return { creator: "", councilId: 0, response: 0, secret: "" };
}

export const MsgCouncilResponseReveal: MessageFns<MsgCouncilResponseReveal> = {
  encode(message: MsgCouncilResponseReveal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.councilId !== 0) {
      writer.uint32(16).uint64(message.councilId);
    }
    if (message.response !== 0) {
      writer.uint32(24).int32(message.response);
    }
    if (message.secret !== "") {
      writer.uint32(34).string(message.secret);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCouncilResponseReveal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCouncilResponseReveal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.councilId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.secret = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCouncilResponseReveal {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      councilId: isSet(object.councilId) ? globalThis.Number(object.councilId) : 0,
      response: isSet(object.response) ? responseFromJSON(object.response) : 0,
      secret: isSet(object.secret) ? globalThis.String(object.secret) : "",
    };
  },

  toJSON(message: MsgCouncilResponseReveal): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.councilId !== 0) {
      obj.councilId = Math.round(message.councilId);
    }
    if (message.response !== 0) {
      obj.response = responseToJSON(message.response);
    }
    if (message.secret !== "") {
      obj.secret = message.secret;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCouncilResponseReveal>, I>>(base?: I): MsgCouncilResponseReveal {
    return MsgCouncilResponseReveal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCouncilResponseReveal>, I>>(object: I): MsgCouncilResponseReveal {
    const message = createBaseMsgCouncilResponseReveal();
    message.creator = object.creator ?? "";
    message.councilId = object.councilId ?? 0;
    message.response = object.response ?? 0;
    message.secret = object.secret ?? "";
    return message;
  },
};

function createBaseMsgCouncilResponseRevealResponse(): MsgCouncilResponseRevealResponse {
  return {};
}

export const MsgCouncilResponseRevealResponse: MessageFns<MsgCouncilResponseRevealResponse> = {
  encode(_: MsgCouncilResponseRevealResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCouncilResponseRevealResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCouncilResponseRevealResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCouncilResponseRevealResponse {
    return {};
  },

  toJSON(_: MsgCouncilResponseRevealResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCouncilResponseRevealResponse>, I>>(
    base?: I,
  ): MsgCouncilResponseRevealResponse {
    return MsgCouncilResponseRevealResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCouncilResponseRevealResponse>, I>>(
    _: I,
  ): MsgCouncilResponseRevealResponse {
    const message = createBaseMsgCouncilResponseRevealResponse();
    return message;
  },
};

function createBaseMsgCouncilRestart(): MsgCouncilRestart {
  return { creator: "", councilId: 0 };
}

export const MsgCouncilRestart: MessageFns<MsgCouncilRestart> = {
  encode(message: MsgCouncilRestart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.councilId !== 0) {
      writer.uint32(16).uint64(message.councilId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCouncilRestart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCouncilRestart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.councilId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCouncilRestart {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      councilId: isSet(object.councilId) ? globalThis.Number(object.councilId) : 0,
    };
  },

  toJSON(message: MsgCouncilRestart): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.councilId !== 0) {
      obj.councilId = Math.round(message.councilId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCouncilRestart>, I>>(base?: I): MsgCouncilRestart {
    return MsgCouncilRestart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCouncilRestart>, I>>(object: I): MsgCouncilRestart {
    const message = createBaseMsgCouncilRestart();
    message.creator = object.creator ?? "";
    message.councilId = object.councilId ?? 0;
    return message;
  },
};

function createBaseMsgCouncilRestartResponse(): MsgCouncilRestartResponse {
  return {};
}

export const MsgCouncilRestartResponse: MessageFns<MsgCouncilRestartResponse> = {
  encode(_: MsgCouncilRestartResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCouncilRestartResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCouncilRestartResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCouncilRestartResponse {
    return {};
  },

  toJSON(_: MsgCouncilRestartResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCouncilRestartResponse>, I>>(base?: I): MsgCouncilRestartResponse {
    return MsgCouncilRestartResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCouncilRestartResponse>, I>>(_: I): MsgCouncilRestartResponse {
    const message = createBaseMsgCouncilRestartResponse();
    return message;
  },
};

function createBaseMsgMatchConfirm(): MsgMatchConfirm {
  return { creator: "", matchId: 0, outcome: 0, votedCards: [] };
}

export const MsgMatchConfirm: MessageFns<MsgMatchConfirm> = {
  encode(message: MsgMatchConfirm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.matchId !== 0) {
      writer.uint32(16).uint64(message.matchId);
    }
    if (message.outcome !== 0) {
      writer.uint32(24).int32(message.outcome);
    }
    for (const v of message.votedCards) {
      SingleVote.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMatchConfirm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMatchConfirm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.matchId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.outcome = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.votedCards.push(SingleVote.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMatchConfirm {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      matchId: isSet(object.matchId) ? globalThis.Number(object.matchId) : 0,
      outcome: isSet(object.outcome) ? outcomeFromJSON(object.outcome) : 0,
      votedCards: globalThis.Array.isArray(object?.votedCards)
        ? object.votedCards.map((e: any) => SingleVote.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgMatchConfirm): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.matchId !== 0) {
      obj.matchId = Math.round(message.matchId);
    }
    if (message.outcome !== 0) {
      obj.outcome = outcomeToJSON(message.outcome);
    }
    if (message.votedCards?.length) {
      obj.votedCards = message.votedCards.map((e) => SingleVote.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMatchConfirm>, I>>(base?: I): MsgMatchConfirm {
    return MsgMatchConfirm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMatchConfirm>, I>>(object: I): MsgMatchConfirm {
    const message = createBaseMsgMatchConfirm();
    message.creator = object.creator ?? "";
    message.matchId = object.matchId ?? 0;
    message.outcome = object.outcome ?? 0;
    message.votedCards = object.votedCards?.map((e) => SingleVote.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgMatchConfirmResponse(): MsgMatchConfirmResponse {
  return {};
}

export const MsgMatchConfirmResponse: MessageFns<MsgMatchConfirmResponse> = {
  encode(_: MsgMatchConfirmResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMatchConfirmResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMatchConfirmResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgMatchConfirmResponse {
    return {};
  },

  toJSON(_: MsgMatchConfirmResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMatchConfirmResponse>, I>>(base?: I): MsgMatchConfirmResponse {
    return MsgMatchConfirmResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMatchConfirmResponse>, I>>(_: I): MsgMatchConfirmResponse {
    const message = createBaseMsgMatchConfirmResponse();
    return message;
  },
};

function createBaseMsgProfileCardSet(): MsgProfileCardSet {
  return { creator: "", cardId: 0 };
}

export const MsgProfileCardSet: MessageFns<MsgProfileCardSet> = {
  encode(message: MsgProfileCardSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.cardId !== 0) {
      writer.uint32(16).uint64(message.cardId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProfileCardSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProfileCardSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cardId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProfileCardSet {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      cardId: isSet(object.cardId) ? globalThis.Number(object.cardId) : 0,
    };
  },

  toJSON(message: MsgProfileCardSet): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.cardId !== 0) {
      obj.cardId = Math.round(message.cardId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProfileCardSet>, I>>(base?: I): MsgProfileCardSet {
    return MsgProfileCardSet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProfileCardSet>, I>>(object: I): MsgProfileCardSet {
    const message = createBaseMsgProfileCardSet();
    message.creator = object.creator ?? "";
    message.cardId = object.cardId ?? 0;
    return message;
  },
};

function createBaseMsgProfileCardSetResponse(): MsgProfileCardSetResponse {
  return {};
}

export const MsgProfileCardSetResponse: MessageFns<MsgProfileCardSetResponse> = {
  encode(_: MsgProfileCardSetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProfileCardSetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProfileCardSetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgProfileCardSetResponse {
    return {};
  },

  toJSON(_: MsgProfileCardSetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProfileCardSetResponse>, I>>(base?: I): MsgProfileCardSetResponse {
    return MsgProfileCardSetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProfileCardSetResponse>, I>>(_: I): MsgProfileCardSetResponse {
    const message = createBaseMsgProfileCardSetResponse();
    return message;
  },
};

function createBaseMsgProfileWebsiteSet(): MsgProfileWebsiteSet {
  return { creator: "", website: "" };
}

export const MsgProfileWebsiteSet: MessageFns<MsgProfileWebsiteSet> = {
  encode(message: MsgProfileWebsiteSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.website !== "") {
      writer.uint32(18).string(message.website);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProfileWebsiteSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProfileWebsiteSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.website = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProfileWebsiteSet {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      website: isSet(object.website) ? globalThis.String(object.website) : "",
    };
  },

  toJSON(message: MsgProfileWebsiteSet): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.website !== "") {
      obj.website = message.website;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProfileWebsiteSet>, I>>(base?: I): MsgProfileWebsiteSet {
    return MsgProfileWebsiteSet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProfileWebsiteSet>, I>>(object: I): MsgProfileWebsiteSet {
    const message = createBaseMsgProfileWebsiteSet();
    message.creator = object.creator ?? "";
    message.website = object.website ?? "";
    return message;
  },
};

function createBaseMsgProfileWebsiteSetResponse(): MsgProfileWebsiteSetResponse {
  return {};
}

export const MsgProfileWebsiteSetResponse: MessageFns<MsgProfileWebsiteSetResponse> = {
  encode(_: MsgProfileWebsiteSetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProfileWebsiteSetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProfileWebsiteSetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgProfileWebsiteSetResponse {
    return {};
  },

  toJSON(_: MsgProfileWebsiteSetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProfileWebsiteSetResponse>, I>>(base?: I): MsgProfileWebsiteSetResponse {
    return MsgProfileWebsiteSetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProfileWebsiteSetResponse>, I>>(_: I): MsgProfileWebsiteSetResponse {
    const message = createBaseMsgProfileWebsiteSetResponse();
    return message;
  },
};

function createBaseMsgProfileBioSet(): MsgProfileBioSet {
  return { creator: "", bio: "" };
}

export const MsgProfileBioSet: MessageFns<MsgProfileBioSet> = {
  encode(message: MsgProfileBioSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.bio !== "") {
      writer.uint32(18).string(message.bio);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProfileBioSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProfileBioSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bio = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProfileBioSet {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      bio: isSet(object.bio) ? globalThis.String(object.bio) : "",
    };
  },

  toJSON(message: MsgProfileBioSet): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.bio !== "") {
      obj.bio = message.bio;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProfileBioSet>, I>>(base?: I): MsgProfileBioSet {
    return MsgProfileBioSet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProfileBioSet>, I>>(object: I): MsgProfileBioSet {
    const message = createBaseMsgProfileBioSet();
    message.creator = object.creator ?? "";
    message.bio = object.bio ?? "";
    return message;
  },
};

function createBaseMsgProfileBioSetResponse(): MsgProfileBioSetResponse {
  return {};
}

export const MsgProfileBioSetResponse: MessageFns<MsgProfileBioSetResponse> = {
  encode(_: MsgProfileBioSetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProfileBioSetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProfileBioSetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgProfileBioSetResponse {
    return {};
  },

  toJSON(_: MsgProfileBioSetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProfileBioSetResponse>, I>>(base?: I): MsgProfileBioSetResponse {
    return MsgProfileBioSetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProfileBioSetResponse>, I>>(_: I): MsgProfileBioSetResponse {
    const message = createBaseMsgProfileBioSetResponse();
    return message;
  },
};

function createBaseMsgBoosterPackOpen(): MsgBoosterPackOpen {
  return { creator: "", boosterPackId: 0 };
}

export const MsgBoosterPackOpen: MessageFns<MsgBoosterPackOpen> = {
  encode(message: MsgBoosterPackOpen, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.boosterPackId !== 0) {
      writer.uint32(16).uint64(message.boosterPackId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBoosterPackOpen {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBoosterPackOpen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.boosterPackId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBoosterPackOpen {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      boosterPackId: isSet(object.boosterPackId) ? globalThis.Number(object.boosterPackId) : 0,
    };
  },

  toJSON(message: MsgBoosterPackOpen): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.boosterPackId !== 0) {
      obj.boosterPackId = Math.round(message.boosterPackId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBoosterPackOpen>, I>>(base?: I): MsgBoosterPackOpen {
    return MsgBoosterPackOpen.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBoosterPackOpen>, I>>(object: I): MsgBoosterPackOpen {
    const message = createBaseMsgBoosterPackOpen();
    message.creator = object.creator ?? "";
    message.boosterPackId = object.boosterPackId ?? 0;
    return message;
  },
};

function createBaseMsgBoosterPackOpenResponse(): MsgBoosterPackOpenResponse {
  return { cardIds: [] };
}

export const MsgBoosterPackOpenResponse: MessageFns<MsgBoosterPackOpenResponse> = {
  encode(message: MsgBoosterPackOpenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.cardIds) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBoosterPackOpenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBoosterPackOpenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.cardIds.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.cardIds.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBoosterPackOpenResponse {
    return {
      cardIds: globalThis.Array.isArray(object?.cardIds) ? object.cardIds.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: MsgBoosterPackOpenResponse): unknown {
    const obj: any = {};
    if (message.cardIds?.length) {
      obj.cardIds = message.cardIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBoosterPackOpenResponse>, I>>(base?: I): MsgBoosterPackOpenResponse {
    return MsgBoosterPackOpenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBoosterPackOpenResponse>, I>>(object: I): MsgBoosterPackOpenResponse {
    const message = createBaseMsgBoosterPackOpenResponse();
    message.cardIds = object.cardIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgBoosterPackTransfer(): MsgBoosterPackTransfer {
  return { creator: "", boosterPackId: 0, receiver: "" };
}

export const MsgBoosterPackTransfer: MessageFns<MsgBoosterPackTransfer> = {
  encode(message: MsgBoosterPackTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.boosterPackId !== 0) {
      writer.uint32(16).uint64(message.boosterPackId);
    }
    if (message.receiver !== "") {
      writer.uint32(26).string(message.receiver);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBoosterPackTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBoosterPackTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.boosterPackId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.receiver = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBoosterPackTransfer {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      boosterPackId: isSet(object.boosterPackId) ? globalThis.Number(object.boosterPackId) : 0,
      receiver: isSet(object.receiver) ? globalThis.String(object.receiver) : "",
    };
  },

  toJSON(message: MsgBoosterPackTransfer): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.boosterPackId !== 0) {
      obj.boosterPackId = Math.round(message.boosterPackId);
    }
    if (message.receiver !== "") {
      obj.receiver = message.receiver;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBoosterPackTransfer>, I>>(base?: I): MsgBoosterPackTransfer {
    return MsgBoosterPackTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBoosterPackTransfer>, I>>(object: I): MsgBoosterPackTransfer {
    const message = createBaseMsgBoosterPackTransfer();
    message.creator = object.creator ?? "";
    message.boosterPackId = object.boosterPackId ?? 0;
    message.receiver = object.receiver ?? "";
    return message;
  },
};

function createBaseMsgBoosterPackTransferResponse(): MsgBoosterPackTransferResponse {
  return {};
}

export const MsgBoosterPackTransferResponse: MessageFns<MsgBoosterPackTransferResponse> = {
  encode(_: MsgBoosterPackTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBoosterPackTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBoosterPackTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgBoosterPackTransferResponse {
    return {};
  },

  toJSON(_: MsgBoosterPackTransferResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBoosterPackTransferResponse>, I>>(base?: I): MsgBoosterPackTransferResponse {
    return MsgBoosterPackTransferResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBoosterPackTransferResponse>, I>>(_: I): MsgBoosterPackTransferResponse {
    const message = createBaseMsgBoosterPackTransferResponse();
    return message;
  },
};

function createBaseMsgSetStoryWriterSet(): MsgSetStoryWriterSet {
  return { creator: "", setId: 0, storyWriter: "" };
}

export const MsgSetStoryWriterSet: MessageFns<MsgSetStoryWriterSet> = {
  encode(message: MsgSetStoryWriterSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.setId !== 0) {
      writer.uint32(16).uint64(message.setId);
    }
    if (message.storyWriter !== "") {
      writer.uint32(26).string(message.storyWriter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetStoryWriterSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetStoryWriterSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.setId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.storyWriter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetStoryWriterSet {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      setId: isSet(object.setId) ? globalThis.Number(object.setId) : 0,
      storyWriter: isSet(object.storyWriter) ? globalThis.String(object.storyWriter) : "",
    };
  },

  toJSON(message: MsgSetStoryWriterSet): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.setId !== 0) {
      obj.setId = Math.round(message.setId);
    }
    if (message.storyWriter !== "") {
      obj.storyWriter = message.storyWriter;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetStoryWriterSet>, I>>(base?: I): MsgSetStoryWriterSet {
    return MsgSetStoryWriterSet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetStoryWriterSet>, I>>(object: I): MsgSetStoryWriterSet {
    const message = createBaseMsgSetStoryWriterSet();
    message.creator = object.creator ?? "";
    message.setId = object.setId ?? 0;
    message.storyWriter = object.storyWriter ?? "";
    return message;
  },
};

function createBaseMsgSetStoryWriterSetResponse(): MsgSetStoryWriterSetResponse {
  return {};
}

export const MsgSetStoryWriterSetResponse: MessageFns<MsgSetStoryWriterSetResponse> = {
  encode(_: MsgSetStoryWriterSetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetStoryWriterSetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetStoryWriterSetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetStoryWriterSetResponse {
    return {};
  },

  toJSON(_: MsgSetStoryWriterSetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetStoryWriterSetResponse>, I>>(base?: I): MsgSetStoryWriterSetResponse {
    return MsgSetStoryWriterSetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetStoryWriterSetResponse>, I>>(_: I): MsgSetStoryWriterSetResponse {
    const message = createBaseMsgSetStoryWriterSetResponse();
    return message;
  },
};

function createBaseMsgSetArtistSet(): MsgSetArtistSet {
  return { creator: "", setId: 0, artist: "" };
}

export const MsgSetArtistSet: MessageFns<MsgSetArtistSet> = {
  encode(message: MsgSetArtistSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.setId !== 0) {
      writer.uint32(16).uint64(message.setId);
    }
    if (message.artist !== "") {
      writer.uint32(26).string(message.artist);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetArtistSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetArtistSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.setId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.artist = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetArtistSet {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      setId: isSet(object.setId) ? globalThis.Number(object.setId) : 0,
      artist: isSet(object.artist) ? globalThis.String(object.artist) : "",
    };
  },

  toJSON(message: MsgSetArtistSet): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.setId !== 0) {
      obj.setId = Math.round(message.setId);
    }
    if (message.artist !== "") {
      obj.artist = message.artist;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetArtistSet>, I>>(base?: I): MsgSetArtistSet {
    return MsgSetArtistSet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetArtistSet>, I>>(object: I): MsgSetArtistSet {
    const message = createBaseMsgSetArtistSet();
    message.creator = object.creator ?? "";
    message.setId = object.setId ?? 0;
    message.artist = object.artist ?? "";
    return message;
  },
};

function createBaseMsgSetArtistSetResponse(): MsgSetArtistSetResponse {
  return {};
}

export const MsgSetArtistSetResponse: MessageFns<MsgSetArtistSetResponse> = {
  encode(_: MsgSetArtistSetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetArtistSetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetArtistSetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetArtistSetResponse {
    return {};
  },

  toJSON(_: MsgSetArtistSetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetArtistSetResponse>, I>>(base?: I): MsgSetArtistSetResponse {
    return MsgSetArtistSetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetArtistSetResponse>, I>>(_: I): MsgSetArtistSetResponse {
    const message = createBaseMsgSetArtistSetResponse();
    return message;
  },
};

function createBaseMsgCardVoteMulti(): MsgCardVoteMulti {
  return { creator: "", votes: [] };
}

export const MsgCardVoteMulti: MessageFns<MsgCardVoteMulti> = {
  encode(message: MsgCardVoteMulti, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    for (const v of message.votes) {
      SingleVote.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardVoteMulti {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardVoteMulti();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.votes.push(SingleVote.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCardVoteMulti {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      votes: globalThis.Array.isArray(object?.votes) ? object.votes.map((e: any) => SingleVote.fromJSON(e)) : [],
    };
  },

  toJSON(message: MsgCardVoteMulti): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.votes?.length) {
      obj.votes = message.votes.map((e) => SingleVote.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardVoteMulti>, I>>(base?: I): MsgCardVoteMulti {
    return MsgCardVoteMulti.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardVoteMulti>, I>>(object: I): MsgCardVoteMulti {
    const message = createBaseMsgCardVoteMulti();
    message.creator = object.creator ?? "";
    message.votes = object.votes?.map((e) => SingleVote.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgCardVoteMultiResponse(): MsgCardVoteMultiResponse {
  return { airdropClaimed: false };
}

export const MsgCardVoteMultiResponse: MessageFns<MsgCardVoteMultiResponse> = {
  encode(message: MsgCardVoteMultiResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.airdropClaimed !== false) {
      writer.uint32(8).bool(message.airdropClaimed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardVoteMultiResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardVoteMultiResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.airdropClaimed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCardVoteMultiResponse {
    return { airdropClaimed: isSet(object.airdropClaimed) ? globalThis.Boolean(object.airdropClaimed) : false };
  },

  toJSON(message: MsgCardVoteMultiResponse): unknown {
    const obj: any = {};
    if (message.airdropClaimed !== false) {
      obj.airdropClaimed = message.airdropClaimed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardVoteMultiResponse>, I>>(base?: I): MsgCardVoteMultiResponse {
    return MsgCardVoteMultiResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardVoteMultiResponse>, I>>(object: I): MsgCardVoteMultiResponse {
    const message = createBaseMsgCardVoteMultiResponse();
    message.airdropClaimed = object.airdropClaimed ?? false;
    return message;
  },
};

function createBaseMsgMatchOpen(): MsgMatchOpen {
  return { creator: "", playerA: "", playerB: "", playerADeck: [], playerBDeck: [] };
}

export const MsgMatchOpen: MessageFns<MsgMatchOpen> = {
  encode(message: MsgMatchOpen, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.playerA !== "") {
      writer.uint32(18).string(message.playerA);
    }
    if (message.playerB !== "") {
      writer.uint32(26).string(message.playerB);
    }
    writer.uint32(34).fork();
    for (const v of message.playerADeck) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(42).fork();
    for (const v of message.playerBDeck) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMatchOpen {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMatchOpen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playerA = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playerB = reader.string();
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.playerADeck.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.playerADeck.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag === 40) {
            message.playerBDeck.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.playerBDeck.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMatchOpen {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      playerA: isSet(object.playerA) ? globalThis.String(object.playerA) : "",
      playerB: isSet(object.playerB) ? globalThis.String(object.playerB) : "",
      playerADeck: globalThis.Array.isArray(object?.playerADeck)
        ? object.playerADeck.map((e: any) => globalThis.Number(e))
        : [],
      playerBDeck: globalThis.Array.isArray(object?.playerBDeck)
        ? object.playerBDeck.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: MsgMatchOpen): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.playerA !== "") {
      obj.playerA = message.playerA;
    }
    if (message.playerB !== "") {
      obj.playerB = message.playerB;
    }
    if (message.playerADeck?.length) {
      obj.playerADeck = message.playerADeck.map((e) => Math.round(e));
    }
    if (message.playerBDeck?.length) {
      obj.playerBDeck = message.playerBDeck.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMatchOpen>, I>>(base?: I): MsgMatchOpen {
    return MsgMatchOpen.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMatchOpen>, I>>(object: I): MsgMatchOpen {
    const message = createBaseMsgMatchOpen();
    message.creator = object.creator ?? "";
    message.playerA = object.playerA ?? "";
    message.playerB = object.playerB ?? "";
    message.playerADeck = object.playerADeck?.map((e) => e) || [];
    message.playerBDeck = object.playerBDeck?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgMatchOpenResponse(): MsgMatchOpenResponse {
  return { matchId: 0 };
}

export const MsgMatchOpenResponse: MessageFns<MsgMatchOpenResponse> = {
  encode(message: MsgMatchOpenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matchId !== 0) {
      writer.uint32(8).uint64(message.matchId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMatchOpenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMatchOpenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.matchId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMatchOpenResponse {
    return { matchId: isSet(object.matchId) ? globalThis.Number(object.matchId) : 0 };
  },

  toJSON(message: MsgMatchOpenResponse): unknown {
    const obj: any = {};
    if (message.matchId !== 0) {
      obj.matchId = Math.round(message.matchId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMatchOpenResponse>, I>>(base?: I): MsgMatchOpenResponse {
    return MsgMatchOpenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMatchOpenResponse>, I>>(object: I): MsgMatchOpenResponse {
    const message = createBaseMsgMatchOpenResponse();
    message.matchId = object.matchId ?? 0;
    return message;
  },
};

function createBaseMsgSetNameSet(): MsgSetNameSet {
  return { creator: "", setId: 0, name: "" };
}

export const MsgSetNameSet: MessageFns<MsgSetNameSet> = {
  encode(message: MsgSetNameSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.setId !== 0) {
      writer.uint32(16).uint64(message.setId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetNameSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetNameSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.setId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetNameSet {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      setId: isSet(object.setId) ? globalThis.Number(object.setId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: MsgSetNameSet): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.setId !== 0) {
      obj.setId = Math.round(message.setId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetNameSet>, I>>(base?: I): MsgSetNameSet {
    return MsgSetNameSet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetNameSet>, I>>(object: I): MsgSetNameSet {
    const message = createBaseMsgSetNameSet();
    message.creator = object.creator ?? "";
    message.setId = object.setId ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseMsgSetNameSetResponse(): MsgSetNameSetResponse {
  return {};
}

export const MsgSetNameSetResponse: MessageFns<MsgSetNameSetResponse> = {
  encode(_: MsgSetNameSetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetNameSetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetNameSetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetNameSetResponse {
    return {};
  },

  toJSON(_: MsgSetNameSetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetNameSetResponse>, I>>(base?: I): MsgSetNameSetResponse {
    return MsgSetNameSetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetNameSetResponse>, I>>(_: I): MsgSetNameSetResponse {
    const message = createBaseMsgSetNameSetResponse();
    return message;
  },
};

function createBaseMsgProfileAliasSet(): MsgProfileAliasSet {
  return { creator: "", alias: "" };
}

export const MsgProfileAliasSet: MessageFns<MsgProfileAliasSet> = {
  encode(message: MsgProfileAliasSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.alias !== "") {
      writer.uint32(18).string(message.alias);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProfileAliasSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProfileAliasSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.alias = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProfileAliasSet {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      alias: isSet(object.alias) ? globalThis.String(object.alias) : "",
    };
  },

  toJSON(message: MsgProfileAliasSet): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.alias !== "") {
      obj.alias = message.alias;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProfileAliasSet>, I>>(base?: I): MsgProfileAliasSet {
    return MsgProfileAliasSet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProfileAliasSet>, I>>(object: I): MsgProfileAliasSet {
    const message = createBaseMsgProfileAliasSet();
    message.creator = object.creator ?? "";
    message.alias = object.alias ?? "";
    return message;
  },
};

function createBaseMsgProfileAliasSetResponse(): MsgProfileAliasSetResponse {
  return {};
}

export const MsgProfileAliasSetResponse: MessageFns<MsgProfileAliasSetResponse> = {
  encode(_: MsgProfileAliasSetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProfileAliasSetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProfileAliasSetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgProfileAliasSetResponse {
    return {};
  },

  toJSON(_: MsgProfileAliasSetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProfileAliasSetResponse>, I>>(base?: I): MsgProfileAliasSetResponse {
    return MsgProfileAliasSetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProfileAliasSetResponse>, I>>(_: I): MsgProfileAliasSetResponse {
    const message = createBaseMsgProfileAliasSetResponse();
    return message;
  },
};

function createBaseMsgEarlyAccessInvite(): MsgEarlyAccessInvite {
  return { creator: "", user: "" };
}

export const MsgEarlyAccessInvite: MessageFns<MsgEarlyAccessInvite> = {
  encode(message: MsgEarlyAccessInvite, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.user !== "") {
      writer.uint32(18).string(message.user);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgEarlyAccessInvite {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEarlyAccessInvite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgEarlyAccessInvite {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      user: isSet(object.user) ? globalThis.String(object.user) : "",
    };
  },

  toJSON(message: MsgEarlyAccessInvite): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgEarlyAccessInvite>, I>>(base?: I): MsgEarlyAccessInvite {
    return MsgEarlyAccessInvite.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgEarlyAccessInvite>, I>>(object: I): MsgEarlyAccessInvite {
    const message = createBaseMsgEarlyAccessInvite();
    message.creator = object.creator ?? "";
    message.user = object.user ?? "";
    return message;
  },
};

function createBaseMsgEarlyAccessInviteResponse(): MsgEarlyAccessInviteResponse {
  return {};
}

export const MsgEarlyAccessInviteResponse: MessageFns<MsgEarlyAccessInviteResponse> = {
  encode(_: MsgEarlyAccessInviteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgEarlyAccessInviteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEarlyAccessInviteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgEarlyAccessInviteResponse {
    return {};
  },

  toJSON(_: MsgEarlyAccessInviteResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgEarlyAccessInviteResponse>, I>>(base?: I): MsgEarlyAccessInviteResponse {
    return MsgEarlyAccessInviteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgEarlyAccessInviteResponse>, I>>(_: I): MsgEarlyAccessInviteResponse {
    const message = createBaseMsgEarlyAccessInviteResponse();
    return message;
  },
};

function createBaseMsgZealyConnect(): MsgZealyConnect {
  return { creator: "", zealyId: "" };
}

export const MsgZealyConnect: MessageFns<MsgZealyConnect> = {
  encode(message: MsgZealyConnect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.zealyId !== "") {
      writer.uint32(18).string(message.zealyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgZealyConnect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgZealyConnect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.zealyId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgZealyConnect {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      zealyId: isSet(object.zealyId) ? globalThis.String(object.zealyId) : "",
    };
  },

  toJSON(message: MsgZealyConnect): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.zealyId !== "") {
      obj.zealyId = message.zealyId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgZealyConnect>, I>>(base?: I): MsgZealyConnect {
    return MsgZealyConnect.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgZealyConnect>, I>>(object: I): MsgZealyConnect {
    const message = createBaseMsgZealyConnect();
    message.creator = object.creator ?? "";
    message.zealyId = object.zealyId ?? "";
    return message;
  },
};

function createBaseMsgZealyConnectResponse(): MsgZealyConnectResponse {
  return {};
}

export const MsgZealyConnectResponse: MessageFns<MsgZealyConnectResponse> = {
  encode(_: MsgZealyConnectResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgZealyConnectResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgZealyConnectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgZealyConnectResponse {
    return {};
  },

  toJSON(_: MsgZealyConnectResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgZealyConnectResponse>, I>>(base?: I): MsgZealyConnectResponse {
    return MsgZealyConnectResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgZealyConnectResponse>, I>>(_: I): MsgZealyConnectResponse {
    const message = createBaseMsgZealyConnectResponse();
    return message;
  },
};

function createBaseMsgEncounterCreate(): MsgEncounterCreate {
  return { creator: "", name: "", drawlist: [], parameters: {}, image: new Uint8Array(0) };
}

export const MsgEncounterCreate: MessageFns<MsgEncounterCreate> = {
  encode(message: MsgEncounterCreate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    writer.uint32(26).fork();
    for (const v of message.drawlist) {
      writer.uint64(v);
    }
    writer.join();
    Object.entries(message.parameters).forEach(([key, value]) => {
      MsgEncounterCreate_ParametersEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.image.length !== 0) {
      writer.uint32(42).bytes(message.image);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgEncounterCreate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEncounterCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.drawlist.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.drawlist.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = MsgEncounterCreate_ParametersEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.parameters[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.image = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgEncounterCreate {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      drawlist: globalThis.Array.isArray(object?.drawlist) ? object.drawlist.map((e: any) => globalThis.Number(e)) : [],
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      image: isSet(object.image) ? bytesFromBase64(object.image) : new Uint8Array(0),
    };
  },

  toJSON(message: MsgEncounterCreate): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.drawlist?.length) {
      obj.drawlist = message.drawlist.map((e) => Math.round(e));
    }
    if (message.parameters) {
      const entries = Object.entries(message.parameters);
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = v;
        });
      }
    }
    if (message.image.length !== 0) {
      obj.image = base64FromBytes(message.image);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgEncounterCreate>, I>>(base?: I): MsgEncounterCreate {
    return MsgEncounterCreate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgEncounterCreate>, I>>(object: I): MsgEncounterCreate {
    const message = createBaseMsgEncounterCreate();
    message.creator = object.creator ?? "";
    message.name = object.name ?? "";
    message.drawlist = object.drawlist?.map((e) => e) || [];
    message.parameters = Object.entries(object.parameters ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.image = object.image ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgEncounterCreate_ParametersEntry(): MsgEncounterCreate_ParametersEntry {
  return { key: "", value: "" };
}

export const MsgEncounterCreate_ParametersEntry: MessageFns<MsgEncounterCreate_ParametersEntry> = {
  encode(message: MsgEncounterCreate_ParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgEncounterCreate_ParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEncounterCreate_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgEncounterCreate_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MsgEncounterCreate_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgEncounterCreate_ParametersEntry>, I>>(
    base?: I,
  ): MsgEncounterCreate_ParametersEntry {
    return MsgEncounterCreate_ParametersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgEncounterCreate_ParametersEntry>, I>>(
    object: I,
  ): MsgEncounterCreate_ParametersEntry {
    const message = createBaseMsgEncounterCreate_ParametersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMsgEncounterCreateResponse(): MsgEncounterCreateResponse {
  return {};
}

export const MsgEncounterCreateResponse: MessageFns<MsgEncounterCreateResponse> = {
  encode(_: MsgEncounterCreateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgEncounterCreateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEncounterCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgEncounterCreateResponse {
    return {};
  },

  toJSON(_: MsgEncounterCreateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgEncounterCreateResponse>, I>>(base?: I): MsgEncounterCreateResponse {
    return MsgEncounterCreateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgEncounterCreateResponse>, I>>(_: I): MsgEncounterCreateResponse {
    const message = createBaseMsgEncounterCreateResponse();
    return message;
  },
};

function createBaseMsgEncounterDo(): MsgEncounterDo {
  return { creator: "", encounterId: 0, user: "" };
}

export const MsgEncounterDo: MessageFns<MsgEncounterDo> = {
  encode(message: MsgEncounterDo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.encounterId !== 0) {
      writer.uint32(16).uint64(message.encounterId);
    }
    if (message.user !== "") {
      writer.uint32(26).string(message.user);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgEncounterDo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEncounterDo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.encounterId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgEncounterDo {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      encounterId: isSet(object.encounterId) ? globalThis.Number(object.encounterId) : 0,
      user: isSet(object.user) ? globalThis.String(object.user) : "",
    };
  },

  toJSON(message: MsgEncounterDo): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.encounterId !== 0) {
      obj.encounterId = Math.round(message.encounterId);
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgEncounterDo>, I>>(base?: I): MsgEncounterDo {
    return MsgEncounterDo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgEncounterDo>, I>>(object: I): MsgEncounterDo {
    const message = createBaseMsgEncounterDo();
    message.creator = object.creator ?? "";
    message.encounterId = object.encounterId ?? 0;
    message.user = object.user ?? "";
    return message;
  },
};

function createBaseMsgEncounterDoResponse(): MsgEncounterDoResponse {
  return {};
}

export const MsgEncounterDoResponse: MessageFns<MsgEncounterDoResponse> = {
  encode(_: MsgEncounterDoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgEncounterDoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEncounterDoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgEncounterDoResponse {
    return {};
  },

  toJSON(_: MsgEncounterDoResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgEncounterDoResponse>, I>>(base?: I): MsgEncounterDoResponse {
    return MsgEncounterDoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgEncounterDoResponse>, I>>(_: I): MsgEncounterDoResponse {
    const message = createBaseMsgEncounterDoResponse();
    return message;
  },
};

function createBaseMsgEncounterClose(): MsgEncounterClose {
  return { creator: "", encounterId: 0, user: "", won: false };
}

export const MsgEncounterClose: MessageFns<MsgEncounterClose> = {
  encode(message: MsgEncounterClose, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.encounterId !== 0) {
      writer.uint32(16).uint64(message.encounterId);
    }
    if (message.user !== "") {
      writer.uint32(26).string(message.user);
    }
    if (message.won !== false) {
      writer.uint32(32).bool(message.won);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgEncounterClose {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEncounterClose();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.encounterId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.won = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgEncounterClose {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      encounterId: isSet(object.encounterId) ? globalThis.Number(object.encounterId) : 0,
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      won: isSet(object.won) ? globalThis.Boolean(object.won) : false,
    };
  },

  toJSON(message: MsgEncounterClose): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.encounterId !== 0) {
      obj.encounterId = Math.round(message.encounterId);
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.won !== false) {
      obj.won = message.won;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgEncounterClose>, I>>(base?: I): MsgEncounterClose {
    return MsgEncounterClose.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgEncounterClose>, I>>(object: I): MsgEncounterClose {
    const message = createBaseMsgEncounterClose();
    message.creator = object.creator ?? "";
    message.encounterId = object.encounterId ?? 0;
    message.user = object.user ?? "";
    message.won = object.won ?? false;
    return message;
  },
};

function createBaseMsgEncounterCloseResponse(): MsgEncounterCloseResponse {
  return {};
}

export const MsgEncounterCloseResponse: MessageFns<MsgEncounterCloseResponse> = {
  encode(_: MsgEncounterCloseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgEncounterCloseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEncounterCloseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgEncounterCloseResponse {
    return {};
  },

  toJSON(_: MsgEncounterCloseResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgEncounterCloseResponse>, I>>(base?: I): MsgEncounterCloseResponse {
    return MsgEncounterCloseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgEncounterCloseResponse>, I>>(_: I): MsgEncounterCloseResponse {
    const message = createBaseMsgEncounterCloseResponse();
    return message;
  },
};

function createBaseMsgEarlyAccessDisinvite(): MsgEarlyAccessDisinvite {
  return { creator: "", user: "" };
}

export const MsgEarlyAccessDisinvite: MessageFns<MsgEarlyAccessDisinvite> = {
  encode(message: MsgEarlyAccessDisinvite, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.user !== "") {
      writer.uint32(18).string(message.user);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgEarlyAccessDisinvite {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEarlyAccessDisinvite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgEarlyAccessDisinvite {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      user: isSet(object.user) ? globalThis.String(object.user) : "",
    };
  },

  toJSON(message: MsgEarlyAccessDisinvite): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgEarlyAccessDisinvite>, I>>(base?: I): MsgEarlyAccessDisinvite {
    return MsgEarlyAccessDisinvite.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgEarlyAccessDisinvite>, I>>(object: I): MsgEarlyAccessDisinvite {
    const message = createBaseMsgEarlyAccessDisinvite();
    message.creator = object.creator ?? "";
    message.user = object.user ?? "";
    return message;
  },
};

function createBaseMsgEarlyAccessDisinviteResponse(): MsgEarlyAccessDisinviteResponse {
  return {};
}

export const MsgEarlyAccessDisinviteResponse: MessageFns<MsgEarlyAccessDisinviteResponse> = {
  encode(_: MsgEarlyAccessDisinviteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgEarlyAccessDisinviteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEarlyAccessDisinviteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgEarlyAccessDisinviteResponse {
    return {};
  },

  toJSON(_: MsgEarlyAccessDisinviteResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgEarlyAccessDisinviteResponse>, I>>(base?: I): MsgEarlyAccessDisinviteResponse {
    return MsgEarlyAccessDisinviteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgEarlyAccessDisinviteResponse>, I>>(_: I): MsgEarlyAccessDisinviteResponse {
    const message = createBaseMsgEarlyAccessDisinviteResponse();
    return message;
  },
};

function createBaseMsgCardBan(): MsgCardBan {
  return { authority: "", cardId: 0 };
}

export const MsgCardBan: MessageFns<MsgCardBan> = {
  encode(message: MsgCardBan, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.cardId !== 0) {
      writer.uint32(16).uint64(message.cardId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardBan {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardBan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cardId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCardBan {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      cardId: isSet(object.cardId) ? globalThis.Number(object.cardId) : 0,
    };
  },

  toJSON(message: MsgCardBan): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.cardId !== 0) {
      obj.cardId = Math.round(message.cardId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardBan>, I>>(base?: I): MsgCardBan {
    return MsgCardBan.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardBan>, I>>(object: I): MsgCardBan {
    const message = createBaseMsgCardBan();
    message.authority = object.authority ?? "";
    message.cardId = object.cardId ?? 0;
    return message;
  },
};

function createBaseMsgCardBanResponse(): MsgCardBanResponse {
  return {};
}

export const MsgCardBanResponse: MessageFns<MsgCardBanResponse> = {
  encode(_: MsgCardBanResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardBanResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardBanResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCardBanResponse {
    return {};
  },

  toJSON(_: MsgCardBanResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardBanResponse>, I>>(base?: I): MsgCardBanResponse {
    return MsgCardBanResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardBanResponse>, I>>(_: I): MsgCardBanResponse {
    const message = createBaseMsgCardBanResponse();
    return message;
  },
};

function createBaseMsgEarlyAccessGrant(): MsgEarlyAccessGrant {
  return { authority: "", users: [] };
}

export const MsgEarlyAccessGrant: MessageFns<MsgEarlyAccessGrant> = {
  encode(message: MsgEarlyAccessGrant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    for (const v of message.users) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgEarlyAccessGrant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEarlyAccessGrant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.users.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgEarlyAccessGrant {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MsgEarlyAccessGrant): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.users?.length) {
      obj.users = message.users;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgEarlyAccessGrant>, I>>(base?: I): MsgEarlyAccessGrant {
    return MsgEarlyAccessGrant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgEarlyAccessGrant>, I>>(object: I): MsgEarlyAccessGrant {
    const message = createBaseMsgEarlyAccessGrant();
    message.authority = object.authority ?? "";
    message.users = object.users?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgEarlyAccessGrantResponse(): MsgEarlyAccessGrantResponse {
  return {};
}

export const MsgEarlyAccessGrantResponse: MessageFns<MsgEarlyAccessGrantResponse> = {
  encode(_: MsgEarlyAccessGrantResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgEarlyAccessGrantResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEarlyAccessGrantResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgEarlyAccessGrantResponse {
    return {};
  },

  toJSON(_: MsgEarlyAccessGrantResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgEarlyAccessGrantResponse>, I>>(base?: I): MsgEarlyAccessGrantResponse {
    return MsgEarlyAccessGrantResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgEarlyAccessGrantResponse>, I>>(_: I): MsgEarlyAccessGrantResponse {
    const message = createBaseMsgEarlyAccessGrantResponse();
    return message;
  },
};

function createBaseMsgSetActivate(): MsgSetActivate {
  return { authority: "", setId: 0 };
}

export const MsgSetActivate: MessageFns<MsgSetActivate> = {
  encode(message: MsgSetActivate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.setId !== 0) {
      writer.uint32(16).uint64(message.setId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetActivate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetActivate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.setId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetActivate {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      setId: isSet(object.setId) ? globalThis.Number(object.setId) : 0,
    };
  },

  toJSON(message: MsgSetActivate): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.setId !== 0) {
      obj.setId = Math.round(message.setId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetActivate>, I>>(base?: I): MsgSetActivate {
    return MsgSetActivate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetActivate>, I>>(object: I): MsgSetActivate {
    const message = createBaseMsgSetActivate();
    message.authority = object.authority ?? "";
    message.setId = object.setId ?? 0;
    return message;
  },
};

function createBaseMsgSetActivateResponse(): MsgSetActivateResponse {
  return {};
}

export const MsgSetActivateResponse: MessageFns<MsgSetActivateResponse> = {
  encode(_: MsgSetActivateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetActivateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetActivateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetActivateResponse {
    return {};
  },

  toJSON(_: MsgSetActivateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetActivateResponse>, I>>(base?: I): MsgSetActivateResponse {
    return MsgSetActivateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetActivateResponse>, I>>(_: I): MsgSetActivateResponse {
    const message = createBaseMsgSetActivateResponse();
    return message;
  },
};

function createBaseMsgCardCopyrightClaim(): MsgCardCopyrightClaim {
  return { authority: "", cardId: 0 };
}

export const MsgCardCopyrightClaim: MessageFns<MsgCardCopyrightClaim> = {
  encode(message: MsgCardCopyrightClaim, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.cardId !== 0) {
      writer.uint32(16).uint64(message.cardId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardCopyrightClaim {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardCopyrightClaim();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cardId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCardCopyrightClaim {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      cardId: isSet(object.cardId) ? globalThis.Number(object.cardId) : 0,
    };
  },

  toJSON(message: MsgCardCopyrightClaim): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.cardId !== 0) {
      obj.cardId = Math.round(message.cardId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardCopyrightClaim>, I>>(base?: I): MsgCardCopyrightClaim {
    return MsgCardCopyrightClaim.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardCopyrightClaim>, I>>(object: I): MsgCardCopyrightClaim {
    const message = createBaseMsgCardCopyrightClaim();
    message.authority = object.authority ?? "";
    message.cardId = object.cardId ?? 0;
    return message;
  },
};

function createBaseMsgCardCopyrightClaimResponse(): MsgCardCopyrightClaimResponse {
  return {};
}

export const MsgCardCopyrightClaimResponse: MessageFns<MsgCardCopyrightClaimResponse> = {
  encode(_: MsgCardCopyrightClaimResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCardCopyrightClaimResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCardCopyrightClaimResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCardCopyrightClaimResponse {
    return {};
  },

  toJSON(_: MsgCardCopyrightClaimResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCardCopyrightClaimResponse>, I>>(base?: I): MsgCardCopyrightClaimResponse {
    return MsgCardCopyrightClaimResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCardCopyrightClaimResponse>, I>>(_: I): MsgCardCopyrightClaimResponse {
    const message = createBaseMsgCardCopyrightClaimResponse();
    return message;
  },
};

/** Msg defines the Msg service. */
export interface Msg {
  /**
   * UpdateParams defines a (governance) operation for updating the module
   * parameters. The authority defaults to the x/gov module account.
   */
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
  UserCreate(request: MsgUserCreate): Promise<MsgUserCreateResponse>;
  CardSchemeBuy(request: MsgCardSchemeBuy): Promise<MsgCardSchemeBuyResponse>;
  CardSaveContent(request: MsgCardSaveContent): Promise<MsgCardSaveContentResponse>;
  CardVote(request: MsgCardVote): Promise<MsgCardVoteResponse>;
  CardTransfer(request: MsgCardTransfer): Promise<MsgCardTransferResponse>;
  CardDonate(request: MsgCardDonate): Promise<MsgCardDonateResponse>;
  CardArtworkAdd(request: MsgCardArtworkAdd): Promise<MsgCardArtworkAddResponse>;
  CardArtistChange(request: MsgCardArtistChange): Promise<MsgCardArtistChangeResponse>;
  CouncilRegister(request: MsgCouncilRegister): Promise<MsgCouncilRegisterResponse>;
  CouncilDeregister(request: MsgCouncilDeregister): Promise<MsgCouncilDeregisterResponse>;
  MatchReport(request: MsgMatchReport): Promise<MsgMatchReportResponse>;
  CouncilCreate(request: MsgCouncilCreate): Promise<MsgCouncilCreateResponse>;
  MatchReporterAppoint(request: MsgMatchReporterAppoint): Promise<MsgMatchReporterAppointResponse>;
  SetCreate(request: MsgSetCreate): Promise<MsgSetCreateResponse>;
  SetCardAdd(request: MsgSetCardAdd): Promise<MsgSetCardAddResponse>;
  SetCardRemove(request: MsgSetCardRemove): Promise<MsgSetCardRemoveResponse>;
  SetContributorAdd(request: MsgSetContributorAdd): Promise<MsgSetContributorAddResponse>;
  SetContributorRemove(request: MsgSetContributorRemove): Promise<MsgSetContributorRemoveResponse>;
  SetFinalize(request: MsgSetFinalize): Promise<MsgSetFinalizeResponse>;
  SetArtworkAdd(request: MsgSetArtworkAdd): Promise<MsgSetArtworkAddResponse>;
  SetStoryAdd(request: MsgSetStoryAdd): Promise<MsgSetStoryAddResponse>;
  BoosterPackBuy(request: MsgBoosterPackBuy): Promise<MsgBoosterPackBuyResponse>;
  SellOfferCreate(request: MsgSellOfferCreate): Promise<MsgSellOfferCreateResponse>;
  SellOfferBuy(request: MsgSellOfferBuy): Promise<MsgSellOfferBuyResponse>;
  SellOfferRemove(request: MsgSellOfferRemove): Promise<MsgSellOfferRemoveResponse>;
  CardRaritySet(request: MsgCardRaritySet): Promise<MsgCardRaritySetResponse>;
  CouncilResponseCommit(request: MsgCouncilResponseCommit): Promise<MsgCouncilResponseCommitResponse>;
  CouncilResponseReveal(request: MsgCouncilResponseReveal): Promise<MsgCouncilResponseRevealResponse>;
  CouncilRestart(request: MsgCouncilRestart): Promise<MsgCouncilRestartResponse>;
  MatchConfirm(request: MsgMatchConfirm): Promise<MsgMatchConfirmResponse>;
  ProfileCardSet(request: MsgProfileCardSet): Promise<MsgProfileCardSetResponse>;
  ProfileWebsiteSet(request: MsgProfileWebsiteSet): Promise<MsgProfileWebsiteSetResponse>;
  ProfileBioSet(request: MsgProfileBioSet): Promise<MsgProfileBioSetResponse>;
  BoosterPackOpen(request: MsgBoosterPackOpen): Promise<MsgBoosterPackOpenResponse>;
  BoosterPackTransfer(request: MsgBoosterPackTransfer): Promise<MsgBoosterPackTransferResponse>;
  SetStoryWriterSet(request: MsgSetStoryWriterSet): Promise<MsgSetStoryWriterSetResponse>;
  SetArtistSet(request: MsgSetArtistSet): Promise<MsgSetArtistSetResponse>;
  CardVoteMulti(request: MsgCardVoteMulti): Promise<MsgCardVoteMultiResponse>;
  MatchOpen(request: MsgMatchOpen): Promise<MsgMatchOpenResponse>;
  SetNameSet(request: MsgSetNameSet): Promise<MsgSetNameSetResponse>;
  ProfileAliasSet(request: MsgProfileAliasSet): Promise<MsgProfileAliasSetResponse>;
  EarlyAccessInvite(request: MsgEarlyAccessInvite): Promise<MsgEarlyAccessInviteResponse>;
  ZealyConnect(request: MsgZealyConnect): Promise<MsgZealyConnectResponse>;
  EncounterCreate(request: MsgEncounterCreate): Promise<MsgEncounterCreateResponse>;
  EncounterDo(request: MsgEncounterDo): Promise<MsgEncounterDoResponse>;
  EncounterClose(request: MsgEncounterClose): Promise<MsgEncounterCloseResponse>;
  EarlyAccessDisinvite(request: MsgEarlyAccessDisinvite): Promise<MsgEarlyAccessDisinviteResponse>;
  CardBan(request: MsgCardBan): Promise<MsgCardBanResponse>;
  EarlyAccessGrant(request: MsgEarlyAccessGrant): Promise<MsgEarlyAccessGrantResponse>;
  SetActivate(request: MsgSetActivate): Promise<MsgSetActivateResponse>;
  CardCopyrightClaim(request: MsgCardCopyrightClaim): Promise<MsgCardCopyrightClaimResponse>;
}

export const MsgServiceName = "cardchain.cardchain.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.UpdateParams = this.UpdateParams.bind(this);
    this.UserCreate = this.UserCreate.bind(this);
    this.CardSchemeBuy = this.CardSchemeBuy.bind(this);
    this.CardSaveContent = this.CardSaveContent.bind(this);
    this.CardVote = this.CardVote.bind(this);
    this.CardTransfer = this.CardTransfer.bind(this);
    this.CardDonate = this.CardDonate.bind(this);
    this.CardArtworkAdd = this.CardArtworkAdd.bind(this);
    this.CardArtistChange = this.CardArtistChange.bind(this);
    this.CouncilRegister = this.CouncilRegister.bind(this);
    this.CouncilDeregister = this.CouncilDeregister.bind(this);
    this.MatchReport = this.MatchReport.bind(this);
    this.CouncilCreate = this.CouncilCreate.bind(this);
    this.MatchReporterAppoint = this.MatchReporterAppoint.bind(this);
    this.SetCreate = this.SetCreate.bind(this);
    this.SetCardAdd = this.SetCardAdd.bind(this);
    this.SetCardRemove = this.SetCardRemove.bind(this);
    this.SetContributorAdd = this.SetContributorAdd.bind(this);
    this.SetContributorRemove = this.SetContributorRemove.bind(this);
    this.SetFinalize = this.SetFinalize.bind(this);
    this.SetArtworkAdd = this.SetArtworkAdd.bind(this);
    this.SetStoryAdd = this.SetStoryAdd.bind(this);
    this.BoosterPackBuy = this.BoosterPackBuy.bind(this);
    this.SellOfferCreate = this.SellOfferCreate.bind(this);
    this.SellOfferBuy = this.SellOfferBuy.bind(this);
    this.SellOfferRemove = this.SellOfferRemove.bind(this);
    this.CardRaritySet = this.CardRaritySet.bind(this);
    this.CouncilResponseCommit = this.CouncilResponseCommit.bind(this);
    this.CouncilResponseReveal = this.CouncilResponseReveal.bind(this);
    this.CouncilRestart = this.CouncilRestart.bind(this);
    this.MatchConfirm = this.MatchConfirm.bind(this);
    this.ProfileCardSet = this.ProfileCardSet.bind(this);
    this.ProfileWebsiteSet = this.ProfileWebsiteSet.bind(this);
    this.ProfileBioSet = this.ProfileBioSet.bind(this);
    this.BoosterPackOpen = this.BoosterPackOpen.bind(this);
    this.BoosterPackTransfer = this.BoosterPackTransfer.bind(this);
    this.SetStoryWriterSet = this.SetStoryWriterSet.bind(this);
    this.SetArtistSet = this.SetArtistSet.bind(this);
    this.CardVoteMulti = this.CardVoteMulti.bind(this);
    this.MatchOpen = this.MatchOpen.bind(this);
    this.SetNameSet = this.SetNameSet.bind(this);
    this.ProfileAliasSet = this.ProfileAliasSet.bind(this);
    this.EarlyAccessInvite = this.EarlyAccessInvite.bind(this);
    this.ZealyConnect = this.ZealyConnect.bind(this);
    this.EncounterCreate = this.EncounterCreate.bind(this);
    this.EncounterDo = this.EncounterDo.bind(this);
    this.EncounterClose = this.EncounterClose.bind(this);
    this.EarlyAccessDisinvite = this.EarlyAccessDisinvite.bind(this);
    this.CardBan = this.CardBan.bind(this);
    this.EarlyAccessGrant = this.EarlyAccessGrant.bind(this);
    this.SetActivate = this.SetActivate.bind(this);
    this.CardCopyrightClaim = this.CardCopyrightClaim.bind(this);
  }
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse> {
    const data = MsgUpdateParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateParams", data);
    return promise.then((data) => MsgUpdateParamsResponse.decode(new BinaryReader(data)));
  }

  UserCreate(request: MsgUserCreate): Promise<MsgUserCreateResponse> {
    const data = MsgUserCreate.encode(request).finish();
    const promise = this.rpc.request(this.service, "UserCreate", data);
    return promise.then((data) => MsgUserCreateResponse.decode(new BinaryReader(data)));
  }

  CardSchemeBuy(request: MsgCardSchemeBuy): Promise<MsgCardSchemeBuyResponse> {
    const data = MsgCardSchemeBuy.encode(request).finish();
    const promise = this.rpc.request(this.service, "CardSchemeBuy", data);
    return promise.then((data) => MsgCardSchemeBuyResponse.decode(new BinaryReader(data)));
  }

  CardSaveContent(request: MsgCardSaveContent): Promise<MsgCardSaveContentResponse> {
    const data = MsgCardSaveContent.encode(request).finish();
    const promise = this.rpc.request(this.service, "CardSaveContent", data);
    return promise.then((data) => MsgCardSaveContentResponse.decode(new BinaryReader(data)));
  }

  CardVote(request: MsgCardVote): Promise<MsgCardVoteResponse> {
    const data = MsgCardVote.encode(request).finish();
    const promise = this.rpc.request(this.service, "CardVote", data);
    return promise.then((data) => MsgCardVoteResponse.decode(new BinaryReader(data)));
  }

  CardTransfer(request: MsgCardTransfer): Promise<MsgCardTransferResponse> {
    const data = MsgCardTransfer.encode(request).finish();
    const promise = this.rpc.request(this.service, "CardTransfer", data);
    return promise.then((data) => MsgCardTransferResponse.decode(new BinaryReader(data)));
  }

  CardDonate(request: MsgCardDonate): Promise<MsgCardDonateResponse> {
    const data = MsgCardDonate.encode(request).finish();
    const promise = this.rpc.request(this.service, "CardDonate", data);
    return promise.then((data) => MsgCardDonateResponse.decode(new BinaryReader(data)));
  }

  CardArtworkAdd(request: MsgCardArtworkAdd): Promise<MsgCardArtworkAddResponse> {
    const data = MsgCardArtworkAdd.encode(request).finish();
    const promise = this.rpc.request(this.service, "CardArtworkAdd", data);
    return promise.then((data) => MsgCardArtworkAddResponse.decode(new BinaryReader(data)));
  }

  CardArtistChange(request: MsgCardArtistChange): Promise<MsgCardArtistChangeResponse> {
    const data = MsgCardArtistChange.encode(request).finish();
    const promise = this.rpc.request(this.service, "CardArtistChange", data);
    return promise.then((data) => MsgCardArtistChangeResponse.decode(new BinaryReader(data)));
  }

  CouncilRegister(request: MsgCouncilRegister): Promise<MsgCouncilRegisterResponse> {
    const data = MsgCouncilRegister.encode(request).finish();
    const promise = this.rpc.request(this.service, "CouncilRegister", data);
    return promise.then((data) => MsgCouncilRegisterResponse.decode(new BinaryReader(data)));
  }

  CouncilDeregister(request: MsgCouncilDeregister): Promise<MsgCouncilDeregisterResponse> {
    const data = MsgCouncilDeregister.encode(request).finish();
    const promise = this.rpc.request(this.service, "CouncilDeregister", data);
    return promise.then((data) => MsgCouncilDeregisterResponse.decode(new BinaryReader(data)));
  }

  MatchReport(request: MsgMatchReport): Promise<MsgMatchReportResponse> {
    const data = MsgMatchReport.encode(request).finish();
    const promise = this.rpc.request(this.service, "MatchReport", data);
    return promise.then((data) => MsgMatchReportResponse.decode(new BinaryReader(data)));
  }

  CouncilCreate(request: MsgCouncilCreate): Promise<MsgCouncilCreateResponse> {
    const data = MsgCouncilCreate.encode(request).finish();
    const promise = this.rpc.request(this.service, "CouncilCreate", data);
    return promise.then((data) => MsgCouncilCreateResponse.decode(new BinaryReader(data)));
  }

  MatchReporterAppoint(request: MsgMatchReporterAppoint): Promise<MsgMatchReporterAppointResponse> {
    const data = MsgMatchReporterAppoint.encode(request).finish();
    const promise = this.rpc.request(this.service, "MatchReporterAppoint", data);
    return promise.then((data) => MsgMatchReporterAppointResponse.decode(new BinaryReader(data)));
  }

  SetCreate(request: MsgSetCreate): Promise<MsgSetCreateResponse> {
    const data = MsgSetCreate.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetCreate", data);
    return promise.then((data) => MsgSetCreateResponse.decode(new BinaryReader(data)));
  }

  SetCardAdd(request: MsgSetCardAdd): Promise<MsgSetCardAddResponse> {
    const data = MsgSetCardAdd.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetCardAdd", data);
    return promise.then((data) => MsgSetCardAddResponse.decode(new BinaryReader(data)));
  }

  SetCardRemove(request: MsgSetCardRemove): Promise<MsgSetCardRemoveResponse> {
    const data = MsgSetCardRemove.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetCardRemove", data);
    return promise.then((data) => MsgSetCardRemoveResponse.decode(new BinaryReader(data)));
  }

  SetContributorAdd(request: MsgSetContributorAdd): Promise<MsgSetContributorAddResponse> {
    const data = MsgSetContributorAdd.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetContributorAdd", data);
    return promise.then((data) => MsgSetContributorAddResponse.decode(new BinaryReader(data)));
  }

  SetContributorRemove(request: MsgSetContributorRemove): Promise<MsgSetContributorRemoveResponse> {
    const data = MsgSetContributorRemove.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetContributorRemove", data);
    return promise.then((data) => MsgSetContributorRemoveResponse.decode(new BinaryReader(data)));
  }

  SetFinalize(request: MsgSetFinalize): Promise<MsgSetFinalizeResponse> {
    const data = MsgSetFinalize.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetFinalize", data);
    return promise.then((data) => MsgSetFinalizeResponse.decode(new BinaryReader(data)));
  }

  SetArtworkAdd(request: MsgSetArtworkAdd): Promise<MsgSetArtworkAddResponse> {
    const data = MsgSetArtworkAdd.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetArtworkAdd", data);
    return promise.then((data) => MsgSetArtworkAddResponse.decode(new BinaryReader(data)));
  }

  SetStoryAdd(request: MsgSetStoryAdd): Promise<MsgSetStoryAddResponse> {
    const data = MsgSetStoryAdd.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetStoryAdd", data);
    return promise.then((data) => MsgSetStoryAddResponse.decode(new BinaryReader(data)));
  }

  BoosterPackBuy(request: MsgBoosterPackBuy): Promise<MsgBoosterPackBuyResponse> {
    const data = MsgBoosterPackBuy.encode(request).finish();
    const promise = this.rpc.request(this.service, "BoosterPackBuy", data);
    return promise.then((data) => MsgBoosterPackBuyResponse.decode(new BinaryReader(data)));
  }

  SellOfferCreate(request: MsgSellOfferCreate): Promise<MsgSellOfferCreateResponse> {
    const data = MsgSellOfferCreate.encode(request).finish();
    const promise = this.rpc.request(this.service, "SellOfferCreate", data);
    return promise.then((data) => MsgSellOfferCreateResponse.decode(new BinaryReader(data)));
  }

  SellOfferBuy(request: MsgSellOfferBuy): Promise<MsgSellOfferBuyResponse> {
    const data = MsgSellOfferBuy.encode(request).finish();
    const promise = this.rpc.request(this.service, "SellOfferBuy", data);
    return promise.then((data) => MsgSellOfferBuyResponse.decode(new BinaryReader(data)));
  }

  SellOfferRemove(request: MsgSellOfferRemove): Promise<MsgSellOfferRemoveResponse> {
    const data = MsgSellOfferRemove.encode(request).finish();
    const promise = this.rpc.request(this.service, "SellOfferRemove", data);
    return promise.then((data) => MsgSellOfferRemoveResponse.decode(new BinaryReader(data)));
  }

  CardRaritySet(request: MsgCardRaritySet): Promise<MsgCardRaritySetResponse> {
    const data = MsgCardRaritySet.encode(request).finish();
    const promise = this.rpc.request(this.service, "CardRaritySet", data);
    return promise.then((data) => MsgCardRaritySetResponse.decode(new BinaryReader(data)));
  }

  CouncilResponseCommit(request: MsgCouncilResponseCommit): Promise<MsgCouncilResponseCommitResponse> {
    const data = MsgCouncilResponseCommit.encode(request).finish();
    const promise = this.rpc.request(this.service, "CouncilResponseCommit", data);
    return promise.then((data) => MsgCouncilResponseCommitResponse.decode(new BinaryReader(data)));
  }

  CouncilResponseReveal(request: MsgCouncilResponseReveal): Promise<MsgCouncilResponseRevealResponse> {
    const data = MsgCouncilResponseReveal.encode(request).finish();
    const promise = this.rpc.request(this.service, "CouncilResponseReveal", data);
    return promise.then((data) => MsgCouncilResponseRevealResponse.decode(new BinaryReader(data)));
  }

  CouncilRestart(request: MsgCouncilRestart): Promise<MsgCouncilRestartResponse> {
    const data = MsgCouncilRestart.encode(request).finish();
    const promise = this.rpc.request(this.service, "CouncilRestart", data);
    return promise.then((data) => MsgCouncilRestartResponse.decode(new BinaryReader(data)));
  }

  MatchConfirm(request: MsgMatchConfirm): Promise<MsgMatchConfirmResponse> {
    const data = MsgMatchConfirm.encode(request).finish();
    const promise = this.rpc.request(this.service, "MatchConfirm", data);
    return promise.then((data) => MsgMatchConfirmResponse.decode(new BinaryReader(data)));
  }

  ProfileCardSet(request: MsgProfileCardSet): Promise<MsgProfileCardSetResponse> {
    const data = MsgProfileCardSet.encode(request).finish();
    const promise = this.rpc.request(this.service, "ProfileCardSet", data);
    return promise.then((data) => MsgProfileCardSetResponse.decode(new BinaryReader(data)));
  }

  ProfileWebsiteSet(request: MsgProfileWebsiteSet): Promise<MsgProfileWebsiteSetResponse> {
    const data = MsgProfileWebsiteSet.encode(request).finish();
    const promise = this.rpc.request(this.service, "ProfileWebsiteSet", data);
    return promise.then((data) => MsgProfileWebsiteSetResponse.decode(new BinaryReader(data)));
  }

  ProfileBioSet(request: MsgProfileBioSet): Promise<MsgProfileBioSetResponse> {
    const data = MsgProfileBioSet.encode(request).finish();
    const promise = this.rpc.request(this.service, "ProfileBioSet", data);
    return promise.then((data) => MsgProfileBioSetResponse.decode(new BinaryReader(data)));
  }

  BoosterPackOpen(request: MsgBoosterPackOpen): Promise<MsgBoosterPackOpenResponse> {
    const data = MsgBoosterPackOpen.encode(request).finish();
    const promise = this.rpc.request(this.service, "BoosterPackOpen", data);
    return promise.then((data) => MsgBoosterPackOpenResponse.decode(new BinaryReader(data)));
  }

  BoosterPackTransfer(request: MsgBoosterPackTransfer): Promise<MsgBoosterPackTransferResponse> {
    const data = MsgBoosterPackTransfer.encode(request).finish();
    const promise = this.rpc.request(this.service, "BoosterPackTransfer", data);
    return promise.then((data) => MsgBoosterPackTransferResponse.decode(new BinaryReader(data)));
  }

  SetStoryWriterSet(request: MsgSetStoryWriterSet): Promise<MsgSetStoryWriterSetResponse> {
    const data = MsgSetStoryWriterSet.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetStoryWriterSet", data);
    return promise.then((data) => MsgSetStoryWriterSetResponse.decode(new BinaryReader(data)));
  }

  SetArtistSet(request: MsgSetArtistSet): Promise<MsgSetArtistSetResponse> {
    const data = MsgSetArtistSet.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetArtistSet", data);
    return promise.then((data) => MsgSetArtistSetResponse.decode(new BinaryReader(data)));
  }

  CardVoteMulti(request: MsgCardVoteMulti): Promise<MsgCardVoteMultiResponse> {
    const data = MsgCardVoteMulti.encode(request).finish();
    const promise = this.rpc.request(this.service, "CardVoteMulti", data);
    return promise.then((data) => MsgCardVoteMultiResponse.decode(new BinaryReader(data)));
  }

  MatchOpen(request: MsgMatchOpen): Promise<MsgMatchOpenResponse> {
    const data = MsgMatchOpen.encode(request).finish();
    const promise = this.rpc.request(this.service, "MatchOpen", data);
    return promise.then((data) => MsgMatchOpenResponse.decode(new BinaryReader(data)));
  }

  SetNameSet(request: MsgSetNameSet): Promise<MsgSetNameSetResponse> {
    const data = MsgSetNameSet.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetNameSet", data);
    return promise.then((data) => MsgSetNameSetResponse.decode(new BinaryReader(data)));
  }

  ProfileAliasSet(request: MsgProfileAliasSet): Promise<MsgProfileAliasSetResponse> {
    const data = MsgProfileAliasSet.encode(request).finish();
    const promise = this.rpc.request(this.service, "ProfileAliasSet", data);
    return promise.then((data) => MsgProfileAliasSetResponse.decode(new BinaryReader(data)));
  }

  EarlyAccessInvite(request: MsgEarlyAccessInvite): Promise<MsgEarlyAccessInviteResponse> {
    const data = MsgEarlyAccessInvite.encode(request).finish();
    const promise = this.rpc.request(this.service, "EarlyAccessInvite", data);
    return promise.then((data) => MsgEarlyAccessInviteResponse.decode(new BinaryReader(data)));
  }

  ZealyConnect(request: MsgZealyConnect): Promise<MsgZealyConnectResponse> {
    const data = MsgZealyConnect.encode(request).finish();
    const promise = this.rpc.request(this.service, "ZealyConnect", data);
    return promise.then((data) => MsgZealyConnectResponse.decode(new BinaryReader(data)));
  }

  EncounterCreate(request: MsgEncounterCreate): Promise<MsgEncounterCreateResponse> {
    const data = MsgEncounterCreate.encode(request).finish();
    const promise = this.rpc.request(this.service, "EncounterCreate", data);
    return promise.then((data) => MsgEncounterCreateResponse.decode(new BinaryReader(data)));
  }

  EncounterDo(request: MsgEncounterDo): Promise<MsgEncounterDoResponse> {
    const data = MsgEncounterDo.encode(request).finish();
    const promise = this.rpc.request(this.service, "EncounterDo", data);
    return promise.then((data) => MsgEncounterDoResponse.decode(new BinaryReader(data)));
  }

  EncounterClose(request: MsgEncounterClose): Promise<MsgEncounterCloseResponse> {
    const data = MsgEncounterClose.encode(request).finish();
    const promise = this.rpc.request(this.service, "EncounterClose", data);
    return promise.then((data) => MsgEncounterCloseResponse.decode(new BinaryReader(data)));
  }

  EarlyAccessDisinvite(request: MsgEarlyAccessDisinvite): Promise<MsgEarlyAccessDisinviteResponse> {
    const data = MsgEarlyAccessDisinvite.encode(request).finish();
    const promise = this.rpc.request(this.service, "EarlyAccessDisinvite", data);
    return promise.then((data) => MsgEarlyAccessDisinviteResponse.decode(new BinaryReader(data)));
  }

  CardBan(request: MsgCardBan): Promise<MsgCardBanResponse> {
    const data = MsgCardBan.encode(request).finish();
    const promise = this.rpc.request(this.service, "CardBan", data);
    return promise.then((data) => MsgCardBanResponse.decode(new BinaryReader(data)));
  }

  EarlyAccessGrant(request: MsgEarlyAccessGrant): Promise<MsgEarlyAccessGrantResponse> {
    const data = MsgEarlyAccessGrant.encode(request).finish();
    const promise = this.rpc.request(this.service, "EarlyAccessGrant", data);
    return promise.then((data) => MsgEarlyAccessGrantResponse.decode(new BinaryReader(data)));
  }

  SetActivate(request: MsgSetActivate): Promise<MsgSetActivateResponse> {
    const data = MsgSetActivate.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetActivate", data);
    return promise.then((data) => MsgSetActivateResponse.decode(new BinaryReader(data)));
  }

  CardCopyrightClaim(request: MsgCardCopyrightClaim): Promise<MsgCardCopyrightClaimResponse> {
    const data = MsgCardCopyrightClaim.encode(request).finish();
    const promise = this.rpc.request(this.service, "CardCopyrightClaim", data);
    return promise.then((data) => MsgCardCopyrightClaimResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
