// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: cardchain/cardchain/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Coin } from "../../cosmos/base/v1beta1/coin";
import {
  CardClass,
  cardClassFromJSON,
  cardClassToJSON,
  CardRarity,
  cardRarityFromJSON,
  cardRarityToJSON,
  CardStatus,
  cardStatusFromJSON,
  cardStatusToJSON,
  CardType,
  cardTypeFromJSON,
  cardTypeToJSON,
} from "./card";
import { CardContent } from "./card_content";
import { CardWithImage } from "./card_with_image";
import { Council } from "./council";
import { Encounter } from "./encounter";
import { EncounterWithImage } from "./encounter_with_image";
import { Match, Outcome, outcomeFromJSON, outcomeToJSON } from "./match";
import { Params } from "./params";
import { SellOffer, SellOfferStatus, sellOfferStatusFromJSON, sellOfferStatusToJSON } from "./sell_offer";
import { Server } from "./server";
import { SetStatus, setStatusFromJSON, setStatusToJSON } from "./set";
import { SetWithArtwork } from "./set_with_artwork";
import { User } from "./user";
import { VotingResults } from "./voting_results";

export const protobufPackage = "cardchain.cardchain";

/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}

/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
  /** params holds all the parameters of this module. */
  params: Params | undefined;
}

export interface QueryCardRequest {
  cardId: number;
}

export interface QueryCardResponse {
  card: CardWithImage | undefined;
}

export interface QueryUserRequest {
  address: string;
}

export interface QueryUserResponse {
  user: User | undefined;
}

export interface QueryCardsRequest {
  owner: string;
  status: CardStatus[];
  cardType: CardType[];
  class: CardClass[];
  sortBy: string;
  nameContains: string;
  keywordsContains: string;
  notesContains: string;
  onlyStarterCard: boolean;
  onlyBalanceAnchors: boolean;
  rarities: CardRarity[];
  multiClassOnly: boolean;
}

export interface QueryCardsResponse {
  cardIds: number[];
}

export interface QueryMatchRequest {
  matchId: number;
}

export interface QueryMatchResponse {
  match: Match | undefined;
}

export interface QuerySetRequest {
  setId: number;
}

export interface QuerySetResponse {
  set: SetWithArtwork | undefined;
}

export interface QuerySellOfferRequest {
  sellOfferId: number;
}

export interface QuerySellOfferResponse {
  sellOffer: SellOffer | undefined;
}

export interface QueryCouncilRequest {
  councilId: number;
}

export interface QueryCouncilResponse {
  council: Council | undefined;
}

export interface QueryServerRequest {
  serverId: number;
}

export interface QueryServerResponse {
  server: Server | undefined;
}

export interface QueryEncounterRequest {
  encounterId: number;
}

export interface QueryEncounterResponse {
  encounter: Encounter | undefined;
}

export interface QueryEncountersRequest {
  owner: string;
}

export interface QueryEncountersResponse {
  encounters: Encounter[];
}

export interface QueryEncounterWithImageRequest {
  encounterId: number;
}

export interface QueryEncounterWithImageResponse {
  encounter: EncounterWithImage | undefined;
}

export interface QueryEncountersWithImageRequest {
  owner: string;
}

export interface QueryEncountersWithImageResponse {
  encounters: EncounterWithImage[];
}

export interface QueryCardchainInfoRequest {
}

export interface QueryCardchainInfoResponse {
  cardAuctionPrice: Coin | undefined;
  activeSets: number[];
  cardsNumber: number;
  matchesNumber: number;
  sellOffersNumber: number;
  councilsNumber: number;
  lastCardModified: number;
}

export interface QuerySetRarityDistributionRequest {
  setId: number;
}

export interface QuerySetRarityDistributionResponse {
  current: number[];
  wanted: number[];
}

export interface QueryAccountFromZealyRequest {
  zealyId: string;
}

export interface QueryAccountFromZealyResponse {
  address: string;
}

export interface QueryVotingResultsRequest {
}

export interface QueryVotingResultsResponse {
  lastVotingResults: VotingResults | undefined;
}

export interface QueryMatchesRequest {
  timestampDown: number;
  timestampUp: number;
  containsUsers: string[];
  reporter: string;
  outcome: Outcome;
  cardsPlayed: number[];
}

export interface QueryMatchesResponse {
  matches: Match[];
  matchIds: number[];
}

export interface QuerySetsRequest {
  status: SetStatus;
  contributors: string[];
  containsCards: number[];
  owner: string;
}

export interface QuerySetsResponse {
  setIds: number[];
}

export interface QueryCardContentRequest {
  cardId: number;
}

export interface QueryCardContentResponse {
  cardContent: CardContent | undefined;
}

export interface QueryCardContentsRequest {
  cardIds: number[];
}

export interface QueryCardContentsResponse {
  cardContents: CardContent[];
}

export interface QuerySellOffersRequest {
  priceDown: Coin | undefined;
  priceUp: Coin | undefined;
  seller: string;
  buyer: string;
  card: number;
  status: SellOfferStatus;
}

export interface QuerySellOffersResponse {
  sellOffers: SellOffer[];
  sellOfferIds: number[];
}

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(_: QueryParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(base?: I): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(_: I): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(message: QueryParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(base?: I): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(object: I): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryCardRequest(): QueryCardRequest {
  return { cardId: 0 };
}

export const QueryCardRequest: MessageFns<QueryCardRequest> = {
  encode(message: QueryCardRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cardId !== 0) {
      writer.uint32(8).uint64(message.cardId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCardRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.cardId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCardRequest {
    return { cardId: isSet(object.cardId) ? globalThis.Number(object.cardId) : 0 };
  },

  toJSON(message: QueryCardRequest): unknown {
    const obj: any = {};
    if (message.cardId !== 0) {
      obj.cardId = Math.round(message.cardId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCardRequest>, I>>(base?: I): QueryCardRequest {
    return QueryCardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCardRequest>, I>>(object: I): QueryCardRequest {
    const message = createBaseQueryCardRequest();
    message.cardId = object.cardId ?? 0;
    return message;
  },
};

function createBaseQueryCardResponse(): QueryCardResponse {
  return { card: undefined };
}

export const QueryCardResponse: MessageFns<QueryCardResponse> = {
  encode(message: QueryCardResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.card !== undefined) {
      CardWithImage.encode(message.card, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCardResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.card = CardWithImage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCardResponse {
    return { card: isSet(object.card) ? CardWithImage.fromJSON(object.card) : undefined };
  },

  toJSON(message: QueryCardResponse): unknown {
    const obj: any = {};
    if (message.card !== undefined) {
      obj.card = CardWithImage.toJSON(message.card);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCardResponse>, I>>(base?: I): QueryCardResponse {
    return QueryCardResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCardResponse>, I>>(object: I): QueryCardResponse {
    const message = createBaseQueryCardResponse();
    message.card = (object.card !== undefined && object.card !== null)
      ? CardWithImage.fromPartial(object.card)
      : undefined;
    return message;
  },
};

function createBaseQueryUserRequest(): QueryUserRequest {
  return { address: "" };
}

export const QueryUserRequest: MessageFns<QueryUserRequest> = {
  encode(message: QueryUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUserRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: QueryUserRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryUserRequest>, I>>(base?: I): QueryUserRequest {
    return QueryUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryUserRequest>, I>>(object: I): QueryUserRequest {
    const message = createBaseQueryUserRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseQueryUserResponse(): QueryUserResponse {
  return { user: undefined };
}

export const QueryUserResponse: MessageFns<QueryUserResponse> = {
  encode(message: QueryUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUserResponse {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  },

  toJSON(message: QueryUserResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryUserResponse>, I>>(base?: I): QueryUserResponse {
    return QueryUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryUserResponse>, I>>(object: I): QueryUserResponse {
    const message = createBaseQueryUserResponse();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseQueryCardsRequest(): QueryCardsRequest {
  return {
    owner: "",
    status: [],
    cardType: [],
    class: [],
    sortBy: "",
    nameContains: "",
    keywordsContains: "",
    notesContains: "",
    onlyStarterCard: false,
    onlyBalanceAnchors: false,
    rarities: [],
    multiClassOnly: false,
  };
}

export const QueryCardsRequest: MessageFns<QueryCardsRequest> = {
  encode(message: QueryCardsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    writer.uint32(18).fork();
    for (const v of message.status) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(26).fork();
    for (const v of message.cardType) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(34).fork();
    for (const v of message.class) {
      writer.int32(v);
    }
    writer.join();
    if (message.sortBy !== "") {
      writer.uint32(42).string(message.sortBy);
    }
    if (message.nameContains !== "") {
      writer.uint32(50).string(message.nameContains);
    }
    if (message.keywordsContains !== "") {
      writer.uint32(58).string(message.keywordsContains);
    }
    if (message.notesContains !== "") {
      writer.uint32(66).string(message.notesContains);
    }
    if (message.onlyStarterCard !== false) {
      writer.uint32(72).bool(message.onlyStarterCard);
    }
    if (message.onlyBalanceAnchors !== false) {
      writer.uint32(80).bool(message.onlyBalanceAnchors);
    }
    writer.uint32(90).fork();
    for (const v of message.rarities) {
      writer.int32(v);
    }
    writer.join();
    if (message.multiClassOnly !== false) {
      writer.uint32(96).bool(message.multiClassOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCardsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCardsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.status.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.status.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag === 24) {
            message.cardType.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.cardType.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag === 32) {
            message.class.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.class.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.nameContains = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.keywordsContains = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.notesContains = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.onlyStarterCard = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.onlyBalanceAnchors = reader.bool();
          continue;
        }
        case 11: {
          if (tag === 88) {
            message.rarities.push(reader.int32() as any);

            continue;
          }

          if (tag === 90) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.rarities.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.multiClassOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCardsRequest {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      status: globalThis.Array.isArray(object?.status) ? object.status.map((e: any) => cardStatusFromJSON(e)) : [],
      cardType: globalThis.Array.isArray(object?.cardType) ? object.cardType.map((e: any) => cardTypeFromJSON(e)) : [],
      class: globalThis.Array.isArray(object?.class) ? object.class.map((e: any) => cardClassFromJSON(e)) : [],
      sortBy: isSet(object.sortBy) ? globalThis.String(object.sortBy) : "",
      nameContains: isSet(object.nameContains) ? globalThis.String(object.nameContains) : "",
      keywordsContains: isSet(object.keywordsContains) ? globalThis.String(object.keywordsContains) : "",
      notesContains: isSet(object.notesContains) ? globalThis.String(object.notesContains) : "",
      onlyStarterCard: isSet(object.onlyStarterCard) ? globalThis.Boolean(object.onlyStarterCard) : false,
      onlyBalanceAnchors: isSet(object.onlyBalanceAnchors) ? globalThis.Boolean(object.onlyBalanceAnchors) : false,
      rarities: globalThis.Array.isArray(object?.rarities)
        ? object.rarities.map((e: any) => cardRarityFromJSON(e))
        : [],
      multiClassOnly: isSet(object.multiClassOnly) ? globalThis.Boolean(object.multiClassOnly) : false,
    };
  },

  toJSON(message: QueryCardsRequest): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.status?.length) {
      obj.status = message.status.map((e) => cardStatusToJSON(e));
    }
    if (message.cardType?.length) {
      obj.cardType = message.cardType.map((e) => cardTypeToJSON(e));
    }
    if (message.class?.length) {
      obj.class = message.class.map((e) => cardClassToJSON(e));
    }
    if (message.sortBy !== "") {
      obj.sortBy = message.sortBy;
    }
    if (message.nameContains !== "") {
      obj.nameContains = message.nameContains;
    }
    if (message.keywordsContains !== "") {
      obj.keywordsContains = message.keywordsContains;
    }
    if (message.notesContains !== "") {
      obj.notesContains = message.notesContains;
    }
    if (message.onlyStarterCard !== false) {
      obj.onlyStarterCard = message.onlyStarterCard;
    }
    if (message.onlyBalanceAnchors !== false) {
      obj.onlyBalanceAnchors = message.onlyBalanceAnchors;
    }
    if (message.rarities?.length) {
      obj.rarities = message.rarities.map((e) => cardRarityToJSON(e));
    }
    if (message.multiClassOnly !== false) {
      obj.multiClassOnly = message.multiClassOnly;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCardsRequest>, I>>(base?: I): QueryCardsRequest {
    return QueryCardsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCardsRequest>, I>>(object: I): QueryCardsRequest {
    const message = createBaseQueryCardsRequest();
    message.owner = object.owner ?? "";
    message.status = object.status?.map((e) => e) || [];
    message.cardType = object.cardType?.map((e) => e) || [];
    message.class = object.class?.map((e) => e) || [];
    message.sortBy = object.sortBy ?? "";
    message.nameContains = object.nameContains ?? "";
    message.keywordsContains = object.keywordsContains ?? "";
    message.notesContains = object.notesContains ?? "";
    message.onlyStarterCard = object.onlyStarterCard ?? false;
    message.onlyBalanceAnchors = object.onlyBalanceAnchors ?? false;
    message.rarities = object.rarities?.map((e) => e) || [];
    message.multiClassOnly = object.multiClassOnly ?? false;
    return message;
  },
};

function createBaseQueryCardsResponse(): QueryCardsResponse {
  return { cardIds: [] };
}

export const QueryCardsResponse: MessageFns<QueryCardsResponse> = {
  encode(message: QueryCardsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.cardIds) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCardsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCardsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.cardIds.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.cardIds.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCardsResponse {
    return {
      cardIds: globalThis.Array.isArray(object?.cardIds) ? object.cardIds.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: QueryCardsResponse): unknown {
    const obj: any = {};
    if (message.cardIds?.length) {
      obj.cardIds = message.cardIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCardsResponse>, I>>(base?: I): QueryCardsResponse {
    return QueryCardsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCardsResponse>, I>>(object: I): QueryCardsResponse {
    const message = createBaseQueryCardsResponse();
    message.cardIds = object.cardIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryMatchRequest(): QueryMatchRequest {
  return { matchId: 0 };
}

export const QueryMatchRequest: MessageFns<QueryMatchRequest> = {
  encode(message: QueryMatchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matchId !== 0) {
      writer.uint32(8).uint64(message.matchId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryMatchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryMatchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.matchId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryMatchRequest {
    return { matchId: isSet(object.matchId) ? globalThis.Number(object.matchId) : 0 };
  },

  toJSON(message: QueryMatchRequest): unknown {
    const obj: any = {};
    if (message.matchId !== 0) {
      obj.matchId = Math.round(message.matchId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryMatchRequest>, I>>(base?: I): QueryMatchRequest {
    return QueryMatchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryMatchRequest>, I>>(object: I): QueryMatchRequest {
    const message = createBaseQueryMatchRequest();
    message.matchId = object.matchId ?? 0;
    return message;
  },
};

function createBaseQueryMatchResponse(): QueryMatchResponse {
  return { match: undefined };
}

export const QueryMatchResponse: MessageFns<QueryMatchResponse> = {
  encode(message: QueryMatchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.match !== undefined) {
      Match.encode(message.match, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryMatchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryMatchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.match = Match.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryMatchResponse {
    return { match: isSet(object.match) ? Match.fromJSON(object.match) : undefined };
  },

  toJSON(message: QueryMatchResponse): unknown {
    const obj: any = {};
    if (message.match !== undefined) {
      obj.match = Match.toJSON(message.match);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryMatchResponse>, I>>(base?: I): QueryMatchResponse {
    return QueryMatchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryMatchResponse>, I>>(object: I): QueryMatchResponse {
    const message = createBaseQueryMatchResponse();
    message.match = (object.match !== undefined && object.match !== null) ? Match.fromPartial(object.match) : undefined;
    return message;
  },
};

function createBaseQuerySetRequest(): QuerySetRequest {
  return { setId: 0 };
}

export const QuerySetRequest: MessageFns<QuerySetRequest> = {
  encode(message: QuerySetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.setId !== 0) {
      writer.uint32(8).uint64(message.setId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.setId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySetRequest {
    return { setId: isSet(object.setId) ? globalThis.Number(object.setId) : 0 };
  },

  toJSON(message: QuerySetRequest): unknown {
    const obj: any = {};
    if (message.setId !== 0) {
      obj.setId = Math.round(message.setId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySetRequest>, I>>(base?: I): QuerySetRequest {
    return QuerySetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySetRequest>, I>>(object: I): QuerySetRequest {
    const message = createBaseQuerySetRequest();
    message.setId = object.setId ?? 0;
    return message;
  },
};

function createBaseQuerySetResponse(): QuerySetResponse {
  return { set: undefined };
}

export const QuerySetResponse: MessageFns<QuerySetResponse> = {
  encode(message: QuerySetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.set !== undefined) {
      SetWithArtwork.encode(message.set, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.set = SetWithArtwork.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySetResponse {
    return { set: isSet(object.set) ? SetWithArtwork.fromJSON(object.set) : undefined };
  },

  toJSON(message: QuerySetResponse): unknown {
    const obj: any = {};
    if (message.set !== undefined) {
      obj.set = SetWithArtwork.toJSON(message.set);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySetResponse>, I>>(base?: I): QuerySetResponse {
    return QuerySetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySetResponse>, I>>(object: I): QuerySetResponse {
    const message = createBaseQuerySetResponse();
    message.set = (object.set !== undefined && object.set !== null)
      ? SetWithArtwork.fromPartial(object.set)
      : undefined;
    return message;
  },
};

function createBaseQuerySellOfferRequest(): QuerySellOfferRequest {
  return { sellOfferId: 0 };
}

export const QuerySellOfferRequest: MessageFns<QuerySellOfferRequest> = {
  encode(message: QuerySellOfferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sellOfferId !== 0) {
      writer.uint32(8).uint64(message.sellOfferId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySellOfferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySellOfferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sellOfferId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySellOfferRequest {
    return { sellOfferId: isSet(object.sellOfferId) ? globalThis.Number(object.sellOfferId) : 0 };
  },

  toJSON(message: QuerySellOfferRequest): unknown {
    const obj: any = {};
    if (message.sellOfferId !== 0) {
      obj.sellOfferId = Math.round(message.sellOfferId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySellOfferRequest>, I>>(base?: I): QuerySellOfferRequest {
    return QuerySellOfferRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySellOfferRequest>, I>>(object: I): QuerySellOfferRequest {
    const message = createBaseQuerySellOfferRequest();
    message.sellOfferId = object.sellOfferId ?? 0;
    return message;
  },
};

function createBaseQuerySellOfferResponse(): QuerySellOfferResponse {
  return { sellOffer: undefined };
}

export const QuerySellOfferResponse: MessageFns<QuerySellOfferResponse> = {
  encode(message: QuerySellOfferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sellOffer !== undefined) {
      SellOffer.encode(message.sellOffer, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySellOfferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySellOfferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sellOffer = SellOffer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySellOfferResponse {
    return { sellOffer: isSet(object.sellOffer) ? SellOffer.fromJSON(object.sellOffer) : undefined };
  },

  toJSON(message: QuerySellOfferResponse): unknown {
    const obj: any = {};
    if (message.sellOffer !== undefined) {
      obj.sellOffer = SellOffer.toJSON(message.sellOffer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySellOfferResponse>, I>>(base?: I): QuerySellOfferResponse {
    return QuerySellOfferResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySellOfferResponse>, I>>(object: I): QuerySellOfferResponse {
    const message = createBaseQuerySellOfferResponse();
    message.sellOffer = (object.sellOffer !== undefined && object.sellOffer !== null)
      ? SellOffer.fromPartial(object.sellOffer)
      : undefined;
    return message;
  },
};

function createBaseQueryCouncilRequest(): QueryCouncilRequest {
  return { councilId: 0 };
}

export const QueryCouncilRequest: MessageFns<QueryCouncilRequest> = {
  encode(message: QueryCouncilRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.councilId !== 0) {
      writer.uint32(8).uint64(message.councilId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCouncilRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCouncilRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.councilId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCouncilRequest {
    return { councilId: isSet(object.councilId) ? globalThis.Number(object.councilId) : 0 };
  },

  toJSON(message: QueryCouncilRequest): unknown {
    const obj: any = {};
    if (message.councilId !== 0) {
      obj.councilId = Math.round(message.councilId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCouncilRequest>, I>>(base?: I): QueryCouncilRequest {
    return QueryCouncilRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCouncilRequest>, I>>(object: I): QueryCouncilRequest {
    const message = createBaseQueryCouncilRequest();
    message.councilId = object.councilId ?? 0;
    return message;
  },
};

function createBaseQueryCouncilResponse(): QueryCouncilResponse {
  return { council: undefined };
}

export const QueryCouncilResponse: MessageFns<QueryCouncilResponse> = {
  encode(message: QueryCouncilResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.council !== undefined) {
      Council.encode(message.council, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCouncilResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCouncilResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.council = Council.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCouncilResponse {
    return { council: isSet(object.council) ? Council.fromJSON(object.council) : undefined };
  },

  toJSON(message: QueryCouncilResponse): unknown {
    const obj: any = {};
    if (message.council !== undefined) {
      obj.council = Council.toJSON(message.council);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCouncilResponse>, I>>(base?: I): QueryCouncilResponse {
    return QueryCouncilResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCouncilResponse>, I>>(object: I): QueryCouncilResponse {
    const message = createBaseQueryCouncilResponse();
    message.council = (object.council !== undefined && object.council !== null)
      ? Council.fromPartial(object.council)
      : undefined;
    return message;
  },
};

function createBaseQueryServerRequest(): QueryServerRequest {
  return { serverId: 0 };
}

export const QueryServerRequest: MessageFns<QueryServerRequest> = {
  encode(message: QueryServerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serverId !== 0) {
      writer.uint32(8).uint64(message.serverId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryServerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryServerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.serverId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryServerRequest {
    return { serverId: isSet(object.serverId) ? globalThis.Number(object.serverId) : 0 };
  },

  toJSON(message: QueryServerRequest): unknown {
    const obj: any = {};
    if (message.serverId !== 0) {
      obj.serverId = Math.round(message.serverId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryServerRequest>, I>>(base?: I): QueryServerRequest {
    return QueryServerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryServerRequest>, I>>(object: I): QueryServerRequest {
    const message = createBaseQueryServerRequest();
    message.serverId = object.serverId ?? 0;
    return message;
  },
};

function createBaseQueryServerResponse(): QueryServerResponse {
  return { server: undefined };
}

export const QueryServerResponse: MessageFns<QueryServerResponse> = {
  encode(message: QueryServerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.server !== undefined) {
      Server.encode(message.server, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryServerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryServerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.server = Server.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryServerResponse {
    return { server: isSet(object.server) ? Server.fromJSON(object.server) : undefined };
  },

  toJSON(message: QueryServerResponse): unknown {
    const obj: any = {};
    if (message.server !== undefined) {
      obj.server = Server.toJSON(message.server);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryServerResponse>, I>>(base?: I): QueryServerResponse {
    return QueryServerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryServerResponse>, I>>(object: I): QueryServerResponse {
    const message = createBaseQueryServerResponse();
    message.server = (object.server !== undefined && object.server !== null)
      ? Server.fromPartial(object.server)
      : undefined;
    return message;
  },
};

function createBaseQueryEncounterRequest(): QueryEncounterRequest {
  return { encounterId: 0 };
}

export const QueryEncounterRequest: MessageFns<QueryEncounterRequest> = {
  encode(message: QueryEncounterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.encounterId !== 0) {
      writer.uint32(8).uint64(message.encounterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEncounterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEncounterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.encounterId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEncounterRequest {
    return { encounterId: isSet(object.encounterId) ? globalThis.Number(object.encounterId) : 0 };
  },

  toJSON(message: QueryEncounterRequest): unknown {
    const obj: any = {};
    if (message.encounterId !== 0) {
      obj.encounterId = Math.round(message.encounterId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEncounterRequest>, I>>(base?: I): QueryEncounterRequest {
    return QueryEncounterRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEncounterRequest>, I>>(object: I): QueryEncounterRequest {
    const message = createBaseQueryEncounterRequest();
    message.encounterId = object.encounterId ?? 0;
    return message;
  },
};

function createBaseQueryEncounterResponse(): QueryEncounterResponse {
  return { encounter: undefined };
}

export const QueryEncounterResponse: MessageFns<QueryEncounterResponse> = {
  encode(message: QueryEncounterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.encounter !== undefined) {
      Encounter.encode(message.encounter, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEncounterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEncounterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.encounter = Encounter.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEncounterResponse {
    return { encounter: isSet(object.encounter) ? Encounter.fromJSON(object.encounter) : undefined };
  },

  toJSON(message: QueryEncounterResponse): unknown {
    const obj: any = {};
    if (message.encounter !== undefined) {
      obj.encounter = Encounter.toJSON(message.encounter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEncounterResponse>, I>>(base?: I): QueryEncounterResponse {
    return QueryEncounterResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEncounterResponse>, I>>(object: I): QueryEncounterResponse {
    const message = createBaseQueryEncounterResponse();
    message.encounter = (object.encounter !== undefined && object.encounter !== null)
      ? Encounter.fromPartial(object.encounter)
      : undefined;
    return message;
  },
};

function createBaseQueryEncountersRequest(): QueryEncountersRequest {
  return { owner: "" };
}

export const QueryEncountersRequest: MessageFns<QueryEncountersRequest> = {
  encode(message: QueryEncountersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEncountersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEncountersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEncountersRequest {
    return { owner: isSet(object.owner) ? globalThis.String(object.owner) : "" };
  },

  toJSON(message: QueryEncountersRequest): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEncountersRequest>, I>>(base?: I): QueryEncountersRequest {
    return QueryEncountersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEncountersRequest>, I>>(object: I): QueryEncountersRequest {
    const message = createBaseQueryEncountersRequest();
    message.owner = object.owner ?? "";
    return message;
  },
};

function createBaseQueryEncountersResponse(): QueryEncountersResponse {
  return { encounters: [] };
}

export const QueryEncountersResponse: MessageFns<QueryEncountersResponse> = {
  encode(message: QueryEncountersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.encounters) {
      Encounter.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEncountersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEncountersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.encounters.push(Encounter.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEncountersResponse {
    return {
      encounters: globalThis.Array.isArray(object?.encounters)
        ? object.encounters.map((e: any) => Encounter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryEncountersResponse): unknown {
    const obj: any = {};
    if (message.encounters?.length) {
      obj.encounters = message.encounters.map((e) => Encounter.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEncountersResponse>, I>>(base?: I): QueryEncountersResponse {
    return QueryEncountersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEncountersResponse>, I>>(object: I): QueryEncountersResponse {
    const message = createBaseQueryEncountersResponse();
    message.encounters = object.encounters?.map((e) => Encounter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryEncounterWithImageRequest(): QueryEncounterWithImageRequest {
  return { encounterId: 0 };
}

export const QueryEncounterWithImageRequest: MessageFns<QueryEncounterWithImageRequest> = {
  encode(message: QueryEncounterWithImageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.encounterId !== 0) {
      writer.uint32(8).uint64(message.encounterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEncounterWithImageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEncounterWithImageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.encounterId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEncounterWithImageRequest {
    return { encounterId: isSet(object.encounterId) ? globalThis.Number(object.encounterId) : 0 };
  },

  toJSON(message: QueryEncounterWithImageRequest): unknown {
    const obj: any = {};
    if (message.encounterId !== 0) {
      obj.encounterId = Math.round(message.encounterId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEncounterWithImageRequest>, I>>(base?: I): QueryEncounterWithImageRequest {
    return QueryEncounterWithImageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEncounterWithImageRequest>, I>>(
    object: I,
  ): QueryEncounterWithImageRequest {
    const message = createBaseQueryEncounterWithImageRequest();
    message.encounterId = object.encounterId ?? 0;
    return message;
  },
};

function createBaseQueryEncounterWithImageResponse(): QueryEncounterWithImageResponse {
  return { encounter: undefined };
}

export const QueryEncounterWithImageResponse: MessageFns<QueryEncounterWithImageResponse> = {
  encode(message: QueryEncounterWithImageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.encounter !== undefined) {
      EncounterWithImage.encode(message.encounter, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEncounterWithImageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEncounterWithImageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.encounter = EncounterWithImage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEncounterWithImageResponse {
    return { encounter: isSet(object.encounter) ? EncounterWithImage.fromJSON(object.encounter) : undefined };
  },

  toJSON(message: QueryEncounterWithImageResponse): unknown {
    const obj: any = {};
    if (message.encounter !== undefined) {
      obj.encounter = EncounterWithImage.toJSON(message.encounter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEncounterWithImageResponse>, I>>(base?: I): QueryEncounterWithImageResponse {
    return QueryEncounterWithImageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEncounterWithImageResponse>, I>>(
    object: I,
  ): QueryEncounterWithImageResponse {
    const message = createBaseQueryEncounterWithImageResponse();
    message.encounter = (object.encounter !== undefined && object.encounter !== null)
      ? EncounterWithImage.fromPartial(object.encounter)
      : undefined;
    return message;
  },
};

function createBaseQueryEncountersWithImageRequest(): QueryEncountersWithImageRequest {
  return { owner: "" };
}

export const QueryEncountersWithImageRequest: MessageFns<QueryEncountersWithImageRequest> = {
  encode(message: QueryEncountersWithImageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEncountersWithImageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEncountersWithImageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEncountersWithImageRequest {
    return { owner: isSet(object.owner) ? globalThis.String(object.owner) : "" };
  },

  toJSON(message: QueryEncountersWithImageRequest): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEncountersWithImageRequest>, I>>(base?: I): QueryEncountersWithImageRequest {
    return QueryEncountersWithImageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEncountersWithImageRequest>, I>>(
    object: I,
  ): QueryEncountersWithImageRequest {
    const message = createBaseQueryEncountersWithImageRequest();
    message.owner = object.owner ?? "";
    return message;
  },
};

function createBaseQueryEncountersWithImageResponse(): QueryEncountersWithImageResponse {
  return { encounters: [] };
}

export const QueryEncountersWithImageResponse: MessageFns<QueryEncountersWithImageResponse> = {
  encode(message: QueryEncountersWithImageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.encounters) {
      EncounterWithImage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEncountersWithImageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEncountersWithImageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.encounters.push(EncounterWithImage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEncountersWithImageResponse {
    return {
      encounters: globalThis.Array.isArray(object?.encounters)
        ? object.encounters.map((e: any) => EncounterWithImage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryEncountersWithImageResponse): unknown {
    const obj: any = {};
    if (message.encounters?.length) {
      obj.encounters = message.encounters.map((e) => EncounterWithImage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEncountersWithImageResponse>, I>>(
    base?: I,
  ): QueryEncountersWithImageResponse {
    return QueryEncountersWithImageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEncountersWithImageResponse>, I>>(
    object: I,
  ): QueryEncountersWithImageResponse {
    const message = createBaseQueryEncountersWithImageResponse();
    message.encounters = object.encounters?.map((e) => EncounterWithImage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryCardchainInfoRequest(): QueryCardchainInfoRequest {
  return {};
}

export const QueryCardchainInfoRequest: MessageFns<QueryCardchainInfoRequest> = {
  encode(_: QueryCardchainInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCardchainInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCardchainInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryCardchainInfoRequest {
    return {};
  },

  toJSON(_: QueryCardchainInfoRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCardchainInfoRequest>, I>>(base?: I): QueryCardchainInfoRequest {
    return QueryCardchainInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCardchainInfoRequest>, I>>(_: I): QueryCardchainInfoRequest {
    const message = createBaseQueryCardchainInfoRequest();
    return message;
  },
};

function createBaseQueryCardchainInfoResponse(): QueryCardchainInfoResponse {
  return {
    cardAuctionPrice: undefined,
    activeSets: [],
    cardsNumber: 0,
    matchesNumber: 0,
    sellOffersNumber: 0,
    councilsNumber: 0,
    lastCardModified: 0,
  };
}

export const QueryCardchainInfoResponse: MessageFns<QueryCardchainInfoResponse> = {
  encode(message: QueryCardchainInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cardAuctionPrice !== undefined) {
      Coin.encode(message.cardAuctionPrice, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.activeSets) {
      writer.uint64(v);
    }
    writer.join();
    if (message.cardsNumber !== 0) {
      writer.uint32(24).uint64(message.cardsNumber);
    }
    if (message.matchesNumber !== 0) {
      writer.uint32(32).uint64(message.matchesNumber);
    }
    if (message.sellOffersNumber !== 0) {
      writer.uint32(40).uint64(message.sellOffersNumber);
    }
    if (message.councilsNumber !== 0) {
      writer.uint32(48).uint64(message.councilsNumber);
    }
    if (message.lastCardModified !== 0) {
      writer.uint32(56).uint64(message.lastCardModified);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCardchainInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCardchainInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cardAuctionPrice = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.activeSets.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.activeSets.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.cardsNumber = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.matchesNumber = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sellOffersNumber = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.councilsNumber = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.lastCardModified = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCardchainInfoResponse {
    return {
      cardAuctionPrice: isSet(object.cardAuctionPrice) ? Coin.fromJSON(object.cardAuctionPrice) : undefined,
      activeSets: globalThis.Array.isArray(object?.activeSets)
        ? object.activeSets.map((e: any) => globalThis.Number(e))
        : [],
      cardsNumber: isSet(object.cardsNumber) ? globalThis.Number(object.cardsNumber) : 0,
      matchesNumber: isSet(object.matchesNumber) ? globalThis.Number(object.matchesNumber) : 0,
      sellOffersNumber: isSet(object.sellOffersNumber) ? globalThis.Number(object.sellOffersNumber) : 0,
      councilsNumber: isSet(object.councilsNumber) ? globalThis.Number(object.councilsNumber) : 0,
      lastCardModified: isSet(object.lastCardModified) ? globalThis.Number(object.lastCardModified) : 0,
    };
  },

  toJSON(message: QueryCardchainInfoResponse): unknown {
    const obj: any = {};
    if (message.cardAuctionPrice !== undefined) {
      obj.cardAuctionPrice = Coin.toJSON(message.cardAuctionPrice);
    }
    if (message.activeSets?.length) {
      obj.activeSets = message.activeSets.map((e) => Math.round(e));
    }
    if (message.cardsNumber !== 0) {
      obj.cardsNumber = Math.round(message.cardsNumber);
    }
    if (message.matchesNumber !== 0) {
      obj.matchesNumber = Math.round(message.matchesNumber);
    }
    if (message.sellOffersNumber !== 0) {
      obj.sellOffersNumber = Math.round(message.sellOffersNumber);
    }
    if (message.councilsNumber !== 0) {
      obj.councilsNumber = Math.round(message.councilsNumber);
    }
    if (message.lastCardModified !== 0) {
      obj.lastCardModified = Math.round(message.lastCardModified);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCardchainInfoResponse>, I>>(base?: I): QueryCardchainInfoResponse {
    return QueryCardchainInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCardchainInfoResponse>, I>>(object: I): QueryCardchainInfoResponse {
    const message = createBaseQueryCardchainInfoResponse();
    message.cardAuctionPrice = (object.cardAuctionPrice !== undefined && object.cardAuctionPrice !== null)
      ? Coin.fromPartial(object.cardAuctionPrice)
      : undefined;
    message.activeSets = object.activeSets?.map((e) => e) || [];
    message.cardsNumber = object.cardsNumber ?? 0;
    message.matchesNumber = object.matchesNumber ?? 0;
    message.sellOffersNumber = object.sellOffersNumber ?? 0;
    message.councilsNumber = object.councilsNumber ?? 0;
    message.lastCardModified = object.lastCardModified ?? 0;
    return message;
  },
};

function createBaseQuerySetRarityDistributionRequest(): QuerySetRarityDistributionRequest {
  return { setId: 0 };
}

export const QuerySetRarityDistributionRequest: MessageFns<QuerySetRarityDistributionRequest> = {
  encode(message: QuerySetRarityDistributionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.setId !== 0) {
      writer.uint32(8).uint64(message.setId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySetRarityDistributionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySetRarityDistributionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.setId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySetRarityDistributionRequest {
    return { setId: isSet(object.setId) ? globalThis.Number(object.setId) : 0 };
  },

  toJSON(message: QuerySetRarityDistributionRequest): unknown {
    const obj: any = {};
    if (message.setId !== 0) {
      obj.setId = Math.round(message.setId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySetRarityDistributionRequest>, I>>(
    base?: I,
  ): QuerySetRarityDistributionRequest {
    return QuerySetRarityDistributionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySetRarityDistributionRequest>, I>>(
    object: I,
  ): QuerySetRarityDistributionRequest {
    const message = createBaseQuerySetRarityDistributionRequest();
    message.setId = object.setId ?? 0;
    return message;
  },
};

function createBaseQuerySetRarityDistributionResponse(): QuerySetRarityDistributionResponse {
  return { current: [], wanted: [] };
}

export const QuerySetRarityDistributionResponse: MessageFns<QuerySetRarityDistributionResponse> = {
  encode(message: QuerySetRarityDistributionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.current) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(18).fork();
    for (const v of message.wanted) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySetRarityDistributionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySetRarityDistributionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.current.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.current.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag === 16) {
            message.wanted.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.wanted.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySetRarityDistributionResponse {
    return {
      current: globalThis.Array.isArray(object?.current) ? object.current.map((e: any) => globalThis.Number(e)) : [],
      wanted: globalThis.Array.isArray(object?.wanted) ? object.wanted.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: QuerySetRarityDistributionResponse): unknown {
    const obj: any = {};
    if (message.current?.length) {
      obj.current = message.current.map((e) => Math.round(e));
    }
    if (message.wanted?.length) {
      obj.wanted = message.wanted.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySetRarityDistributionResponse>, I>>(
    base?: I,
  ): QuerySetRarityDistributionResponse {
    return QuerySetRarityDistributionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySetRarityDistributionResponse>, I>>(
    object: I,
  ): QuerySetRarityDistributionResponse {
    const message = createBaseQuerySetRarityDistributionResponse();
    message.current = object.current?.map((e) => e) || [];
    message.wanted = object.wanted?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryAccountFromZealyRequest(): QueryAccountFromZealyRequest {
  return { zealyId: "" };
}

export const QueryAccountFromZealyRequest: MessageFns<QueryAccountFromZealyRequest> = {
  encode(message: QueryAccountFromZealyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.zealyId !== "") {
      writer.uint32(10).string(message.zealyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAccountFromZealyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAccountFromZealyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.zealyId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAccountFromZealyRequest {
    return { zealyId: isSet(object.zealyId) ? globalThis.String(object.zealyId) : "" };
  },

  toJSON(message: QueryAccountFromZealyRequest): unknown {
    const obj: any = {};
    if (message.zealyId !== "") {
      obj.zealyId = message.zealyId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAccountFromZealyRequest>, I>>(base?: I): QueryAccountFromZealyRequest {
    return QueryAccountFromZealyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAccountFromZealyRequest>, I>>(object: I): QueryAccountFromZealyRequest {
    const message = createBaseQueryAccountFromZealyRequest();
    message.zealyId = object.zealyId ?? "";
    return message;
  },
};

function createBaseQueryAccountFromZealyResponse(): QueryAccountFromZealyResponse {
  return { address: "" };
}

export const QueryAccountFromZealyResponse: MessageFns<QueryAccountFromZealyResponse> = {
  encode(message: QueryAccountFromZealyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAccountFromZealyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAccountFromZealyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAccountFromZealyResponse {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: QueryAccountFromZealyResponse): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAccountFromZealyResponse>, I>>(base?: I): QueryAccountFromZealyResponse {
    return QueryAccountFromZealyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAccountFromZealyResponse>, I>>(
    object: I,
  ): QueryAccountFromZealyResponse {
    const message = createBaseQueryAccountFromZealyResponse();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseQueryVotingResultsRequest(): QueryVotingResultsRequest {
  return {};
}

export const QueryVotingResultsRequest: MessageFns<QueryVotingResultsRequest> = {
  encode(_: QueryVotingResultsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryVotingResultsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryVotingResultsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryVotingResultsRequest {
    return {};
  },

  toJSON(_: QueryVotingResultsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryVotingResultsRequest>, I>>(base?: I): QueryVotingResultsRequest {
    return QueryVotingResultsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryVotingResultsRequest>, I>>(_: I): QueryVotingResultsRequest {
    const message = createBaseQueryVotingResultsRequest();
    return message;
  },
};

function createBaseQueryVotingResultsResponse(): QueryVotingResultsResponse {
  return { lastVotingResults: undefined };
}

export const QueryVotingResultsResponse: MessageFns<QueryVotingResultsResponse> = {
  encode(message: QueryVotingResultsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lastVotingResults !== undefined) {
      VotingResults.encode(message.lastVotingResults, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryVotingResultsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryVotingResultsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lastVotingResults = VotingResults.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryVotingResultsResponse {
    return {
      lastVotingResults: isSet(object.lastVotingResults) ? VotingResults.fromJSON(object.lastVotingResults) : undefined,
    };
  },

  toJSON(message: QueryVotingResultsResponse): unknown {
    const obj: any = {};
    if (message.lastVotingResults !== undefined) {
      obj.lastVotingResults = VotingResults.toJSON(message.lastVotingResults);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryVotingResultsResponse>, I>>(base?: I): QueryVotingResultsResponse {
    return QueryVotingResultsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryVotingResultsResponse>, I>>(object: I): QueryVotingResultsResponse {
    const message = createBaseQueryVotingResultsResponse();
    message.lastVotingResults = (object.lastVotingResults !== undefined && object.lastVotingResults !== null)
      ? VotingResults.fromPartial(object.lastVotingResults)
      : undefined;
    return message;
  },
};

function createBaseQueryMatchesRequest(): QueryMatchesRequest {
  return { timestampDown: 0, timestampUp: 0, containsUsers: [], reporter: "", outcome: 0, cardsPlayed: [] };
}

export const QueryMatchesRequest: MessageFns<QueryMatchesRequest> = {
  encode(message: QueryMatchesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestampDown !== 0) {
      writer.uint32(8).uint64(message.timestampDown);
    }
    if (message.timestampUp !== 0) {
      writer.uint32(16).uint64(message.timestampUp);
    }
    for (const v of message.containsUsers) {
      writer.uint32(26).string(v!);
    }
    if (message.reporter !== "") {
      writer.uint32(34).string(message.reporter);
    }
    if (message.outcome !== 0) {
      writer.uint32(40).int32(message.outcome);
    }
    writer.uint32(50).fork();
    for (const v of message.cardsPlayed) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryMatchesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryMatchesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestampDown = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestampUp = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.containsUsers.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reporter = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.outcome = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.cardsPlayed.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.cardsPlayed.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryMatchesRequest {
    return {
      timestampDown: isSet(object.timestampDown) ? globalThis.Number(object.timestampDown) : 0,
      timestampUp: isSet(object.timestampUp) ? globalThis.Number(object.timestampUp) : 0,
      containsUsers: globalThis.Array.isArray(object?.containsUsers)
        ? object.containsUsers.map((e: any) => globalThis.String(e))
        : [],
      reporter: isSet(object.reporter) ? globalThis.String(object.reporter) : "",
      outcome: isSet(object.outcome) ? outcomeFromJSON(object.outcome) : 0,
      cardsPlayed: globalThis.Array.isArray(object?.cardsPlayed)
        ? object.cardsPlayed.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: QueryMatchesRequest): unknown {
    const obj: any = {};
    if (message.timestampDown !== 0) {
      obj.timestampDown = Math.round(message.timestampDown);
    }
    if (message.timestampUp !== 0) {
      obj.timestampUp = Math.round(message.timestampUp);
    }
    if (message.containsUsers?.length) {
      obj.containsUsers = message.containsUsers;
    }
    if (message.reporter !== "") {
      obj.reporter = message.reporter;
    }
    if (message.outcome !== 0) {
      obj.outcome = outcomeToJSON(message.outcome);
    }
    if (message.cardsPlayed?.length) {
      obj.cardsPlayed = message.cardsPlayed.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryMatchesRequest>, I>>(base?: I): QueryMatchesRequest {
    return QueryMatchesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryMatchesRequest>, I>>(object: I): QueryMatchesRequest {
    const message = createBaseQueryMatchesRequest();
    message.timestampDown = object.timestampDown ?? 0;
    message.timestampUp = object.timestampUp ?? 0;
    message.containsUsers = object.containsUsers?.map((e) => e) || [];
    message.reporter = object.reporter ?? "";
    message.outcome = object.outcome ?? 0;
    message.cardsPlayed = object.cardsPlayed?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryMatchesResponse(): QueryMatchesResponse {
  return { matches: [], matchIds: [] };
}

export const QueryMatchesResponse: MessageFns<QueryMatchesResponse> = {
  encode(message: QueryMatchesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matches) {
      Match.encode(v!, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.matchIds) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryMatchesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryMatchesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matches.push(Match.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.matchIds.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.matchIds.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryMatchesResponse {
    return {
      matches: globalThis.Array.isArray(object?.matches) ? object.matches.map((e: any) => Match.fromJSON(e)) : [],
      matchIds: globalThis.Array.isArray(object?.matchIds) ? object.matchIds.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: QueryMatchesResponse): unknown {
    const obj: any = {};
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => Match.toJSON(e));
    }
    if (message.matchIds?.length) {
      obj.matchIds = message.matchIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryMatchesResponse>, I>>(base?: I): QueryMatchesResponse {
    return QueryMatchesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryMatchesResponse>, I>>(object: I): QueryMatchesResponse {
    const message = createBaseQueryMatchesResponse();
    message.matches = object.matches?.map((e) => Match.fromPartial(e)) || [];
    message.matchIds = object.matchIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseQuerySetsRequest(): QuerySetsRequest {
  return { status: 0, contributors: [], containsCards: [], owner: "" };
}

export const QuerySetsRequest: MessageFns<QuerySetsRequest> = {
  encode(message: QuerySetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    for (const v of message.contributors) {
      writer.uint32(18).string(v!);
    }
    writer.uint32(26).fork();
    for (const v of message.containsCards) {
      writer.uint64(v);
    }
    writer.join();
    if (message.owner !== "") {
      writer.uint32(34).string(message.owner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contributors.push(reader.string());
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.containsCards.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.containsCards.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySetsRequest {
    return {
      status: isSet(object.status) ? setStatusFromJSON(object.status) : 0,
      contributors: globalThis.Array.isArray(object?.contributors)
        ? object.contributors.map((e: any) => globalThis.String(e))
        : [],
      containsCards: globalThis.Array.isArray(object?.containsCards)
        ? object.containsCards.map((e: any) => globalThis.Number(e))
        : [],
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
    };
  },

  toJSON(message: QuerySetsRequest): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = setStatusToJSON(message.status);
    }
    if (message.contributors?.length) {
      obj.contributors = message.contributors;
    }
    if (message.containsCards?.length) {
      obj.containsCards = message.containsCards.map((e) => Math.round(e));
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySetsRequest>, I>>(base?: I): QuerySetsRequest {
    return QuerySetsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySetsRequest>, I>>(object: I): QuerySetsRequest {
    const message = createBaseQuerySetsRequest();
    message.status = object.status ?? 0;
    message.contributors = object.contributors?.map((e) => e) || [];
    message.containsCards = object.containsCards?.map((e) => e) || [];
    message.owner = object.owner ?? "";
    return message;
  },
};

function createBaseQuerySetsResponse(): QuerySetsResponse {
  return { setIds: [] };
}

export const QuerySetsResponse: MessageFns<QuerySetsResponse> = {
  encode(message: QuerySetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.setIds) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.setIds.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.setIds.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySetsResponse {
    return {
      setIds: globalThis.Array.isArray(object?.setIds) ? object.setIds.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: QuerySetsResponse): unknown {
    const obj: any = {};
    if (message.setIds?.length) {
      obj.setIds = message.setIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySetsResponse>, I>>(base?: I): QuerySetsResponse {
    return QuerySetsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySetsResponse>, I>>(object: I): QuerySetsResponse {
    const message = createBaseQuerySetsResponse();
    message.setIds = object.setIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryCardContentRequest(): QueryCardContentRequest {
  return { cardId: 0 };
}

export const QueryCardContentRequest: MessageFns<QueryCardContentRequest> = {
  encode(message: QueryCardContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cardId !== 0) {
      writer.uint32(8).uint64(message.cardId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCardContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCardContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.cardId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCardContentRequest {
    return { cardId: isSet(object.cardId) ? globalThis.Number(object.cardId) : 0 };
  },

  toJSON(message: QueryCardContentRequest): unknown {
    const obj: any = {};
    if (message.cardId !== 0) {
      obj.cardId = Math.round(message.cardId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCardContentRequest>, I>>(base?: I): QueryCardContentRequest {
    return QueryCardContentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCardContentRequest>, I>>(object: I): QueryCardContentRequest {
    const message = createBaseQueryCardContentRequest();
    message.cardId = object.cardId ?? 0;
    return message;
  },
};

function createBaseQueryCardContentResponse(): QueryCardContentResponse {
  return { cardContent: undefined };
}

export const QueryCardContentResponse: MessageFns<QueryCardContentResponse> = {
  encode(message: QueryCardContentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cardContent !== undefined) {
      CardContent.encode(message.cardContent, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCardContentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCardContentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cardContent = CardContent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCardContentResponse {
    return { cardContent: isSet(object.cardContent) ? CardContent.fromJSON(object.cardContent) : undefined };
  },

  toJSON(message: QueryCardContentResponse): unknown {
    const obj: any = {};
    if (message.cardContent !== undefined) {
      obj.cardContent = CardContent.toJSON(message.cardContent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCardContentResponse>, I>>(base?: I): QueryCardContentResponse {
    return QueryCardContentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCardContentResponse>, I>>(object: I): QueryCardContentResponse {
    const message = createBaseQueryCardContentResponse();
    message.cardContent = (object.cardContent !== undefined && object.cardContent !== null)
      ? CardContent.fromPartial(object.cardContent)
      : undefined;
    return message;
  },
};

function createBaseQueryCardContentsRequest(): QueryCardContentsRequest {
  return { cardIds: [] };
}

export const QueryCardContentsRequest: MessageFns<QueryCardContentsRequest> = {
  encode(message: QueryCardContentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.cardIds) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCardContentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCardContentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.cardIds.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.cardIds.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCardContentsRequest {
    return {
      cardIds: globalThis.Array.isArray(object?.cardIds) ? object.cardIds.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: QueryCardContentsRequest): unknown {
    const obj: any = {};
    if (message.cardIds?.length) {
      obj.cardIds = message.cardIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCardContentsRequest>, I>>(base?: I): QueryCardContentsRequest {
    return QueryCardContentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCardContentsRequest>, I>>(object: I): QueryCardContentsRequest {
    const message = createBaseQueryCardContentsRequest();
    message.cardIds = object.cardIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryCardContentsResponse(): QueryCardContentsResponse {
  return { cardContents: [] };
}

export const QueryCardContentsResponse: MessageFns<QueryCardContentsResponse> = {
  encode(message: QueryCardContentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cardContents) {
      CardContent.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCardContentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCardContentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cardContents.push(CardContent.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCardContentsResponse {
    return {
      cardContents: globalThis.Array.isArray(object?.cardContents)
        ? object.cardContents.map((e: any) => CardContent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryCardContentsResponse): unknown {
    const obj: any = {};
    if (message.cardContents?.length) {
      obj.cardContents = message.cardContents.map((e) => CardContent.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCardContentsResponse>, I>>(base?: I): QueryCardContentsResponse {
    return QueryCardContentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCardContentsResponse>, I>>(object: I): QueryCardContentsResponse {
    const message = createBaseQueryCardContentsResponse();
    message.cardContents = object.cardContents?.map((e) => CardContent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQuerySellOffersRequest(): QuerySellOffersRequest {
  return { priceDown: undefined, priceUp: undefined, seller: "", buyer: "", card: 0, status: 0 };
}

export const QuerySellOffersRequest: MessageFns<QuerySellOffersRequest> = {
  encode(message: QuerySellOffersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.priceDown !== undefined) {
      Coin.encode(message.priceDown, writer.uint32(10).fork()).join();
    }
    if (message.priceUp !== undefined) {
      Coin.encode(message.priceUp, writer.uint32(18).fork()).join();
    }
    if (message.seller !== "") {
      writer.uint32(26).string(message.seller);
    }
    if (message.buyer !== "") {
      writer.uint32(34).string(message.buyer);
    }
    if (message.card !== 0) {
      writer.uint32(40).uint64(message.card);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySellOffersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySellOffersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.priceDown = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.priceUp = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.seller = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.buyer = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.card = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySellOffersRequest {
    return {
      priceDown: isSet(object.priceDown) ? Coin.fromJSON(object.priceDown) : undefined,
      priceUp: isSet(object.priceUp) ? Coin.fromJSON(object.priceUp) : undefined,
      seller: isSet(object.seller) ? globalThis.String(object.seller) : "",
      buyer: isSet(object.buyer) ? globalThis.String(object.buyer) : "",
      card: isSet(object.card) ? globalThis.Number(object.card) : 0,
      status: isSet(object.status) ? sellOfferStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: QuerySellOffersRequest): unknown {
    const obj: any = {};
    if (message.priceDown !== undefined) {
      obj.priceDown = Coin.toJSON(message.priceDown);
    }
    if (message.priceUp !== undefined) {
      obj.priceUp = Coin.toJSON(message.priceUp);
    }
    if (message.seller !== "") {
      obj.seller = message.seller;
    }
    if (message.buyer !== "") {
      obj.buyer = message.buyer;
    }
    if (message.card !== 0) {
      obj.card = Math.round(message.card);
    }
    if (message.status !== 0) {
      obj.status = sellOfferStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySellOffersRequest>, I>>(base?: I): QuerySellOffersRequest {
    return QuerySellOffersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySellOffersRequest>, I>>(object: I): QuerySellOffersRequest {
    const message = createBaseQuerySellOffersRequest();
    message.priceDown = (object.priceDown !== undefined && object.priceDown !== null)
      ? Coin.fromPartial(object.priceDown)
      : undefined;
    message.priceUp = (object.priceUp !== undefined && object.priceUp !== null)
      ? Coin.fromPartial(object.priceUp)
      : undefined;
    message.seller = object.seller ?? "";
    message.buyer = object.buyer ?? "";
    message.card = object.card ?? 0;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseQuerySellOffersResponse(): QuerySellOffersResponse {
  return { sellOffers: [], sellOfferIds: [] };
}

export const QuerySellOffersResponse: MessageFns<QuerySellOffersResponse> = {
  encode(message: QuerySellOffersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sellOffers) {
      SellOffer.encode(v!, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.sellOfferIds) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySellOffersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySellOffersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sellOffers.push(SellOffer.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.sellOfferIds.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.sellOfferIds.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySellOffersResponse {
    return {
      sellOffers: globalThis.Array.isArray(object?.sellOffers)
        ? object.sellOffers.map((e: any) => SellOffer.fromJSON(e))
        : [],
      sellOfferIds: globalThis.Array.isArray(object?.sellOfferIds)
        ? object.sellOfferIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: QuerySellOffersResponse): unknown {
    const obj: any = {};
    if (message.sellOffers?.length) {
      obj.sellOffers = message.sellOffers.map((e) => SellOffer.toJSON(e));
    }
    if (message.sellOfferIds?.length) {
      obj.sellOfferIds = message.sellOfferIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySellOffersResponse>, I>>(base?: I): QuerySellOffersResponse {
    return QuerySellOffersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySellOffersResponse>, I>>(object: I): QuerySellOffersResponse {
    const message = createBaseQuerySellOffersResponse();
    message.sellOffers = object.sellOffers?.map((e) => SellOffer.fromPartial(e)) || [];
    message.sellOfferIds = object.sellOfferIds?.map((e) => e) || [];
    return message;
  },
};

/** Query defines the gRPC querier service. */
export interface Query {
  /** Parameters queries the parameters of the module. */
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
  /** Queries a list of Card items. */
  Card(request: QueryCardRequest): Promise<QueryCardResponse>;
  /** Queries a list of User items. */
  User(request: QueryUserRequest): Promise<QueryUserResponse>;
  /** Queries a list of Cards items. */
  Cards(request: QueryCardsRequest): Promise<QueryCardsResponse>;
  /** Queries a list of Match items. */
  Match(request: QueryMatchRequest): Promise<QueryMatchResponse>;
  /** Queries a list of Set items. */
  Set(request: QuerySetRequest): Promise<QuerySetResponse>;
  /** Queries a list of SellOffer items. */
  SellOffer(request: QuerySellOfferRequest): Promise<QuerySellOfferResponse>;
  /** Queries a list of Council items. */
  Council(request: QueryCouncilRequest): Promise<QueryCouncilResponse>;
  /** Queries a list of Server items. */
  Server(request: QueryServerRequest): Promise<QueryServerResponse>;
  /** Queries a list of Encounter items. */
  Encounter(request: QueryEncounterRequest): Promise<QueryEncounterResponse>;
  /** Queries a list of Encounters items. */
  Encounters(request: QueryEncountersRequest): Promise<QueryEncountersResponse>;
  /** Queries a list of EncounterWithImage items. */
  EncounterWithImage(request: QueryEncounterWithImageRequest): Promise<QueryEncounterWithImageResponse>;
  /** Queries a list of EncountersWithImage items. */
  EncountersWithImage(request: QueryEncountersWithImageRequest): Promise<QueryEncountersWithImageResponse>;
  /** Queries a list of CardchainInfo items. */
  CardchainInfo(request: QueryCardchainInfoRequest): Promise<QueryCardchainInfoResponse>;
  /** Queries a list of SetRarityDistribution items. */
  SetRarityDistribution(request: QuerySetRarityDistributionRequest): Promise<QuerySetRarityDistributionResponse>;
  /** Queries a list of AccountFromZealy items. */
  AccountFromZealy(request: QueryAccountFromZealyRequest): Promise<QueryAccountFromZealyResponse>;
  /** Queries a list of VotingResults items. */
  VotingResults(request: QueryVotingResultsRequest): Promise<QueryVotingResultsResponse>;
  /** Queries a list of Matches items. */
  Matches(request: QueryMatchesRequest): Promise<QueryMatchesResponse>;
  /** Queries a list of Sets items. */
  Sets(request: QuerySetsRequest): Promise<QuerySetsResponse>;
  /** Queries a list of CardContent items. */
  CardContent(request: QueryCardContentRequest): Promise<QueryCardContentResponse>;
  /** Queries a list of CardContents items. */
  CardContents(request: QueryCardContentsRequest): Promise<QueryCardContentsResponse>;
  /** Queries a list of SellOffers items. */
  SellOffers(request: QuerySellOffersRequest): Promise<QuerySellOffersResponse>;
}

export const QueryServiceName = "cardchain.cardchain.Query";
export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceName;
    this.rpc = rpc;
    this.Params = this.Params.bind(this);
    this.Card = this.Card.bind(this);
    this.User = this.User.bind(this);
    this.Cards = this.Cards.bind(this);
    this.Match = this.Match.bind(this);
    this.Set = this.Set.bind(this);
    this.SellOffer = this.SellOffer.bind(this);
    this.Council = this.Council.bind(this);
    this.Server = this.Server.bind(this);
    this.Encounter = this.Encounter.bind(this);
    this.Encounters = this.Encounters.bind(this);
    this.EncounterWithImage = this.EncounterWithImage.bind(this);
    this.EncountersWithImage = this.EncountersWithImage.bind(this);
    this.CardchainInfo = this.CardchainInfo.bind(this);
    this.SetRarityDistribution = this.SetRarityDistribution.bind(this);
    this.AccountFromZealy = this.AccountFromZealy.bind(this);
    this.VotingResults = this.VotingResults.bind(this);
    this.Matches = this.Matches.bind(this);
    this.Sets = this.Sets.bind(this);
    this.CardContent = this.CardContent.bind(this);
    this.CardContents = this.CardContents.bind(this);
    this.SellOffers = this.SellOffers.bind(this);
  }
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse> {
    const data = QueryParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Params", data);
    return promise.then((data) => QueryParamsResponse.decode(new BinaryReader(data)));
  }

  Card(request: QueryCardRequest): Promise<QueryCardResponse> {
    const data = QueryCardRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Card", data);
    return promise.then((data) => QueryCardResponse.decode(new BinaryReader(data)));
  }

  User(request: QueryUserRequest): Promise<QueryUserResponse> {
    const data = QueryUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "User", data);
    return promise.then((data) => QueryUserResponse.decode(new BinaryReader(data)));
  }

  Cards(request: QueryCardsRequest): Promise<QueryCardsResponse> {
    const data = QueryCardsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Cards", data);
    return promise.then((data) => QueryCardsResponse.decode(new BinaryReader(data)));
  }

  Match(request: QueryMatchRequest): Promise<QueryMatchResponse> {
    const data = QueryMatchRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Match", data);
    return promise.then((data) => QueryMatchResponse.decode(new BinaryReader(data)));
  }

  Set(request: QuerySetRequest): Promise<QuerySetResponse> {
    const data = QuerySetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Set", data);
    return promise.then((data) => QuerySetResponse.decode(new BinaryReader(data)));
  }

  SellOffer(request: QuerySellOfferRequest): Promise<QuerySellOfferResponse> {
    const data = QuerySellOfferRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SellOffer", data);
    return promise.then((data) => QuerySellOfferResponse.decode(new BinaryReader(data)));
  }

  Council(request: QueryCouncilRequest): Promise<QueryCouncilResponse> {
    const data = QueryCouncilRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Council", data);
    return promise.then((data) => QueryCouncilResponse.decode(new BinaryReader(data)));
  }

  Server(request: QueryServerRequest): Promise<QueryServerResponse> {
    const data = QueryServerRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Server", data);
    return promise.then((data) => QueryServerResponse.decode(new BinaryReader(data)));
  }

  Encounter(request: QueryEncounterRequest): Promise<QueryEncounterResponse> {
    const data = QueryEncounterRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Encounter", data);
    return promise.then((data) => QueryEncounterResponse.decode(new BinaryReader(data)));
  }

  Encounters(request: QueryEncountersRequest): Promise<QueryEncountersResponse> {
    const data = QueryEncountersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Encounters", data);
    return promise.then((data) => QueryEncountersResponse.decode(new BinaryReader(data)));
  }

  EncounterWithImage(request: QueryEncounterWithImageRequest): Promise<QueryEncounterWithImageResponse> {
    const data = QueryEncounterWithImageRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EncounterWithImage", data);
    return promise.then((data) => QueryEncounterWithImageResponse.decode(new BinaryReader(data)));
  }

  EncountersWithImage(request: QueryEncountersWithImageRequest): Promise<QueryEncountersWithImageResponse> {
    const data = QueryEncountersWithImageRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EncountersWithImage", data);
    return promise.then((data) => QueryEncountersWithImageResponse.decode(new BinaryReader(data)));
  }

  CardchainInfo(request: QueryCardchainInfoRequest): Promise<QueryCardchainInfoResponse> {
    const data = QueryCardchainInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CardchainInfo", data);
    return promise.then((data) => QueryCardchainInfoResponse.decode(new BinaryReader(data)));
  }

  SetRarityDistribution(request: QuerySetRarityDistributionRequest): Promise<QuerySetRarityDistributionResponse> {
    const data = QuerySetRarityDistributionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetRarityDistribution", data);
    return promise.then((data) => QuerySetRarityDistributionResponse.decode(new BinaryReader(data)));
  }

  AccountFromZealy(request: QueryAccountFromZealyRequest): Promise<QueryAccountFromZealyResponse> {
    const data = QueryAccountFromZealyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AccountFromZealy", data);
    return promise.then((data) => QueryAccountFromZealyResponse.decode(new BinaryReader(data)));
  }

  VotingResults(request: QueryVotingResultsRequest): Promise<QueryVotingResultsResponse> {
    const data = QueryVotingResultsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "VotingResults", data);
    return promise.then((data) => QueryVotingResultsResponse.decode(new BinaryReader(data)));
  }

  Matches(request: QueryMatchesRequest): Promise<QueryMatchesResponse> {
    const data = QueryMatchesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Matches", data);
    return promise.then((data) => QueryMatchesResponse.decode(new BinaryReader(data)));
  }

  Sets(request: QuerySetsRequest): Promise<QuerySetsResponse> {
    const data = QuerySetsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Sets", data);
    return promise.then((data) => QuerySetsResponse.decode(new BinaryReader(data)));
  }

  CardContent(request: QueryCardContentRequest): Promise<QueryCardContentResponse> {
    const data = QueryCardContentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CardContent", data);
    return promise.then((data) => QueryCardContentResponse.decode(new BinaryReader(data)));
  }

  CardContents(request: QueryCardContentsRequest): Promise<QueryCardContentsResponse> {
    const data = QueryCardContentsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CardContents", data);
    return promise.then((data) => QueryCardContentsResponse.decode(new BinaryReader(data)));
  }

  SellOffers(request: QuerySellOffersRequest): Promise<QuerySellOffersResponse> {
    const data = QuerySellOffersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SellOffers", data);
    return promise.then((data) => QuerySellOffersResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
