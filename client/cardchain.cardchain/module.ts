// Generated by Ignite ignite.com/cli

import { SigningStargateClient, DeliverTxResponse, StdFee } from "@cosmjs/stargate";
import { EncodeObject, GeneratedType, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { IgniteClient } from "../client"
import { MissingWalletError } from "../helpers"
import { Api } from "./rest";
import { MsgUpdateParams } from "../types/cardchain/cardchain/tx";
import { MsgUserCreate } from "../types/cardchain/cardchain/tx";
import { MsgCardSchemeBuy } from "../types/cardchain/cardchain/tx";
import { MsgCardSaveContent } from "../types/cardchain/cardchain/tx";
import { MsgCardVote } from "../types/cardchain/cardchain/tx";
import { MsgCardTransfer } from "../types/cardchain/cardchain/tx";
import { MsgCardDonate } from "../types/cardchain/cardchain/tx";
import { MsgCardArtworkAdd } from "../types/cardchain/cardchain/tx";
import { MsgCardArtistChange } from "../types/cardchain/cardchain/tx";
import { MsgCouncilRegister } from "../types/cardchain/cardchain/tx";
import { MsgCouncilDeregister } from "../types/cardchain/cardchain/tx";
import { MsgMatchReport } from "../types/cardchain/cardchain/tx";
import { MsgCouncilCreate } from "../types/cardchain/cardchain/tx";
import { MsgMatchReporterAppoint } from "../types/cardchain/cardchain/tx";
import { MsgSetCreate } from "../types/cardchain/cardchain/tx";
import { MsgSetCardAdd } from "../types/cardchain/cardchain/tx";
import { MsgSetCardRemove } from "../types/cardchain/cardchain/tx";
import { MsgSetContributorAdd } from "../types/cardchain/cardchain/tx";
import { MsgSetContributorRemove } from "../types/cardchain/cardchain/tx";
import { MsgSetFinalize } from "../types/cardchain/cardchain/tx";
import { MsgSetArtworkAdd } from "../types/cardchain/cardchain/tx";
import { MsgSetStoryAdd } from "../types/cardchain/cardchain/tx";
import { MsgBoosterPackBuy } from "../types/cardchain/cardchain/tx";
import { MsgSellOfferCreate } from "../types/cardchain/cardchain/tx";
import { MsgSellOfferBuy } from "../types/cardchain/cardchain/tx";
import { MsgSellOfferRemove } from "../types/cardchain/cardchain/tx";
import { MsgCardRaritySet } from "../types/cardchain/cardchain/tx";
import { MsgCouncilResponseCommit } from "../types/cardchain/cardchain/tx";
import { MsgCouncilResponseReveal } from "../types/cardchain/cardchain/tx";
import { MsgCouncilRestart } from "../types/cardchain/cardchain/tx";
import { MsgMatchConfirm } from "../types/cardchain/cardchain/tx";
import { MsgProfileCardSet } from "../types/cardchain/cardchain/tx";
import { MsgProfileWebsiteSet } from "../types/cardchain/cardchain/tx";
import { MsgProfileBioSet } from "../types/cardchain/cardchain/tx";
import { MsgBoosterPackOpen } from "../types/cardchain/cardchain/tx";
import { MsgBoosterPackTransfer } from "../types/cardchain/cardchain/tx";
import { MsgSetStoryWriterSet } from "../types/cardchain/cardchain/tx";
import { MsgSetArtistSet } from "../types/cardchain/cardchain/tx";
import { MsgCardVoteMulti } from "../types/cardchain/cardchain/tx";
import { MsgMatchOpen } from "../types/cardchain/cardchain/tx";
import { MsgSetNameSet } from "../types/cardchain/cardchain/tx";
import { MsgProfileAliasSet } from "../types/cardchain/cardchain/tx";
import { MsgEarlyAccessInvite } from "../types/cardchain/cardchain/tx";
import { MsgZealyConnect } from "../types/cardchain/cardchain/tx";
import { MsgEncounterCreate } from "../types/cardchain/cardchain/tx";
import { MsgEncounterDo } from "../types/cardchain/cardchain/tx";
import { MsgEncounterClose } from "../types/cardchain/cardchain/tx";
import { MsgEarlyAccessDisinvite } from "../types/cardchain/cardchain/tx";
import { MsgCardBan } from "../types/cardchain/cardchain/tx";
import { MsgEarlyAccessGrant } from "../types/cardchain/cardchain/tx";
import { MsgSetActivate } from "../types/cardchain/cardchain/tx";
import { MsgCardCopyrightClaim } from "../types/cardchain/cardchain/tx";

import { Card as typeCard} from "./types"
import { TimeStamp as typeTimeStamp} from "./types"
import { CardContent as typeCardContent} from "./types"
import { CardWithImage as typeCardWithImage} from "./types"
import { Council as typeCouncil} from "./types"
import { WrapClearResponse as typeWrapClearResponse} from "./types"
import { WrapHashResponse as typeWrapHashResponse} from "./types"
import { Encounter as typeEncounter} from "./types"
import { EncounterWithImage as typeEncounterWithImage} from "./types"
import { Image as typeImage} from "./types"
import { Match as typeMatch} from "./types"
import { MatchPlayer as typeMatchPlayer} from "./types"
import { Params as typeParams} from "./types"
import { RunningAverage as typeRunningAverage} from "./types"
import { SellOffer as typeSellOffer} from "./types"
import { Server as typeServer} from "./types"
import { Set as typeSet} from "./types"
import { InnerRarities as typeInnerRarities} from "./types"
import { AddrWithQuantity as typeAddrWithQuantity} from "./types"
import { SetWithArtwork as typeSetWithArtwork} from "./types"
import { User as typeUser} from "./types"
import { EarlyAccess as typeEarlyAccess} from "./types"
import { BoosterPack as typeBoosterPack} from "./types"
import { AirDrops as typeAirDrops} from "./types"
import { VotingResult as typeVotingResult} from "./types"
import { SingleVote as typeSingleVote} from "./types"
import { VotingResults as typeVotingResults} from "./types"
import { Zealy as typeZealy} from "./types"

export { MsgUpdateParams, MsgUserCreate, MsgCardSchemeBuy, MsgCardSaveContent, MsgCardVote, MsgCardTransfer, MsgCardDonate, MsgCardArtworkAdd, MsgCardArtistChange, MsgCouncilRegister, MsgCouncilDeregister, MsgMatchReport, MsgCouncilCreate, MsgMatchReporterAppoint, MsgSetCreate, MsgSetCardAdd, MsgSetCardRemove, MsgSetContributorAdd, MsgSetContributorRemove, MsgSetFinalize, MsgSetArtworkAdd, MsgSetStoryAdd, MsgBoosterPackBuy, MsgSellOfferCreate, MsgSellOfferBuy, MsgSellOfferRemove, MsgCardRaritySet, MsgCouncilResponseCommit, MsgCouncilResponseReveal, MsgCouncilRestart, MsgMatchConfirm, MsgProfileCardSet, MsgProfileWebsiteSet, MsgProfileBioSet, MsgBoosterPackOpen, MsgBoosterPackTransfer, MsgSetStoryWriterSet, MsgSetArtistSet, MsgCardVoteMulti, MsgMatchOpen, MsgSetNameSet, MsgProfileAliasSet, MsgEarlyAccessInvite, MsgZealyConnect, MsgEncounterCreate, MsgEncounterDo, MsgEncounterClose, MsgEarlyAccessDisinvite, MsgCardBan, MsgEarlyAccessGrant, MsgSetActivate, MsgCardCopyrightClaim };

type sendMsgUpdateParamsParams = {
  value: MsgUpdateParams,
  fee?: StdFee,
  memo?: string
};

type sendMsgUserCreateParams = {
  value: MsgUserCreate,
  fee?: StdFee,
  memo?: string
};

type sendMsgCardSchemeBuyParams = {
  value: MsgCardSchemeBuy,
  fee?: StdFee,
  memo?: string
};

type sendMsgCardSaveContentParams = {
  value: MsgCardSaveContent,
  fee?: StdFee,
  memo?: string
};

type sendMsgCardVoteParams = {
  value: MsgCardVote,
  fee?: StdFee,
  memo?: string
};

type sendMsgCardTransferParams = {
  value: MsgCardTransfer,
  fee?: StdFee,
  memo?: string
};

type sendMsgCardDonateParams = {
  value: MsgCardDonate,
  fee?: StdFee,
  memo?: string
};

type sendMsgCardArtworkAddParams = {
  value: MsgCardArtworkAdd,
  fee?: StdFee,
  memo?: string
};

type sendMsgCardArtistChangeParams = {
  value: MsgCardArtistChange,
  fee?: StdFee,
  memo?: string
};

type sendMsgCouncilRegisterParams = {
  value: MsgCouncilRegister,
  fee?: StdFee,
  memo?: string
};

type sendMsgCouncilDeregisterParams = {
  value: MsgCouncilDeregister,
  fee?: StdFee,
  memo?: string
};

type sendMsgMatchReportParams = {
  value: MsgMatchReport,
  fee?: StdFee,
  memo?: string
};

type sendMsgCouncilCreateParams = {
  value: MsgCouncilCreate,
  fee?: StdFee,
  memo?: string
};

type sendMsgMatchReporterAppointParams = {
  value: MsgMatchReporterAppoint,
  fee?: StdFee,
  memo?: string
};

type sendMsgSetCreateParams = {
  value: MsgSetCreate,
  fee?: StdFee,
  memo?: string
};

type sendMsgSetCardAddParams = {
  value: MsgSetCardAdd,
  fee?: StdFee,
  memo?: string
};

type sendMsgSetCardRemoveParams = {
  value: MsgSetCardRemove,
  fee?: StdFee,
  memo?: string
};

type sendMsgSetContributorAddParams = {
  value: MsgSetContributorAdd,
  fee?: StdFee,
  memo?: string
};

type sendMsgSetContributorRemoveParams = {
  value: MsgSetContributorRemove,
  fee?: StdFee,
  memo?: string
};

type sendMsgSetFinalizeParams = {
  value: MsgSetFinalize,
  fee?: StdFee,
  memo?: string
};

type sendMsgSetArtworkAddParams = {
  value: MsgSetArtworkAdd,
  fee?: StdFee,
  memo?: string
};

type sendMsgSetStoryAddParams = {
  value: MsgSetStoryAdd,
  fee?: StdFee,
  memo?: string
};

type sendMsgBoosterPackBuyParams = {
  value: MsgBoosterPackBuy,
  fee?: StdFee,
  memo?: string
};

type sendMsgSellOfferCreateParams = {
  value: MsgSellOfferCreate,
  fee?: StdFee,
  memo?: string
};

type sendMsgSellOfferBuyParams = {
  value: MsgSellOfferBuy,
  fee?: StdFee,
  memo?: string
};

type sendMsgSellOfferRemoveParams = {
  value: MsgSellOfferRemove,
  fee?: StdFee,
  memo?: string
};

type sendMsgCardRaritySetParams = {
  value: MsgCardRaritySet,
  fee?: StdFee,
  memo?: string
};

type sendMsgCouncilResponseCommitParams = {
  value: MsgCouncilResponseCommit,
  fee?: StdFee,
  memo?: string
};

type sendMsgCouncilResponseRevealParams = {
  value: MsgCouncilResponseReveal,
  fee?: StdFee,
  memo?: string
};

type sendMsgCouncilRestartParams = {
  value: MsgCouncilRestart,
  fee?: StdFee,
  memo?: string
};

type sendMsgMatchConfirmParams = {
  value: MsgMatchConfirm,
  fee?: StdFee,
  memo?: string
};

type sendMsgProfileCardSetParams = {
  value: MsgProfileCardSet,
  fee?: StdFee,
  memo?: string
};

type sendMsgProfileWebsiteSetParams = {
  value: MsgProfileWebsiteSet,
  fee?: StdFee,
  memo?: string
};

type sendMsgProfileBioSetParams = {
  value: MsgProfileBioSet,
  fee?: StdFee,
  memo?: string
};

type sendMsgBoosterPackOpenParams = {
  value: MsgBoosterPackOpen,
  fee?: StdFee,
  memo?: string
};

type sendMsgBoosterPackTransferParams = {
  value: MsgBoosterPackTransfer,
  fee?: StdFee,
  memo?: string
};

type sendMsgSetStoryWriterSetParams = {
  value: MsgSetStoryWriterSet,
  fee?: StdFee,
  memo?: string
};

type sendMsgSetArtistSetParams = {
  value: MsgSetArtistSet,
  fee?: StdFee,
  memo?: string
};

type sendMsgCardVoteMultiParams = {
  value: MsgCardVoteMulti,
  fee?: StdFee,
  memo?: string
};

type sendMsgMatchOpenParams = {
  value: MsgMatchOpen,
  fee?: StdFee,
  memo?: string
};

type sendMsgSetNameSetParams = {
  value: MsgSetNameSet,
  fee?: StdFee,
  memo?: string
};

type sendMsgProfileAliasSetParams = {
  value: MsgProfileAliasSet,
  fee?: StdFee,
  memo?: string
};

type sendMsgEarlyAccessInviteParams = {
  value: MsgEarlyAccessInvite,
  fee?: StdFee,
  memo?: string
};

type sendMsgZealyConnectParams = {
  value: MsgZealyConnect,
  fee?: StdFee,
  memo?: string
};

type sendMsgEncounterCreateParams = {
  value: MsgEncounterCreate,
  fee?: StdFee,
  memo?: string
};

type sendMsgEncounterDoParams = {
  value: MsgEncounterDo,
  fee?: StdFee,
  memo?: string
};

type sendMsgEncounterCloseParams = {
  value: MsgEncounterClose,
  fee?: StdFee,
  memo?: string
};

type sendMsgEarlyAccessDisinviteParams = {
  value: MsgEarlyAccessDisinvite,
  fee?: StdFee,
  memo?: string
};

type sendMsgCardBanParams = {
  value: MsgCardBan,
  fee?: StdFee,
  memo?: string
};

type sendMsgEarlyAccessGrantParams = {
  value: MsgEarlyAccessGrant,
  fee?: StdFee,
  memo?: string
};

type sendMsgSetActivateParams = {
  value: MsgSetActivate,
  fee?: StdFee,
  memo?: string
};

type sendMsgCardCopyrightClaimParams = {
  value: MsgCardCopyrightClaim,
  fee?: StdFee,
  memo?: string
};


type msgUpdateParamsParams = {
  value: MsgUpdateParams,
};

type msgUserCreateParams = {
  value: MsgUserCreate,
};

type msgCardSchemeBuyParams = {
  value: MsgCardSchemeBuy,
};

type msgCardSaveContentParams = {
  value: MsgCardSaveContent,
};

type msgCardVoteParams = {
  value: MsgCardVote,
};

type msgCardTransferParams = {
  value: MsgCardTransfer,
};

type msgCardDonateParams = {
  value: MsgCardDonate,
};

type msgCardArtworkAddParams = {
  value: MsgCardArtworkAdd,
};

type msgCardArtistChangeParams = {
  value: MsgCardArtistChange,
};

type msgCouncilRegisterParams = {
  value: MsgCouncilRegister,
};

type msgCouncilDeregisterParams = {
  value: MsgCouncilDeregister,
};

type msgMatchReportParams = {
  value: MsgMatchReport,
};

type msgCouncilCreateParams = {
  value: MsgCouncilCreate,
};

type msgMatchReporterAppointParams = {
  value: MsgMatchReporterAppoint,
};

type msgSetCreateParams = {
  value: MsgSetCreate,
};

type msgSetCardAddParams = {
  value: MsgSetCardAdd,
};

type msgSetCardRemoveParams = {
  value: MsgSetCardRemove,
};

type msgSetContributorAddParams = {
  value: MsgSetContributorAdd,
};

type msgSetContributorRemoveParams = {
  value: MsgSetContributorRemove,
};

type msgSetFinalizeParams = {
  value: MsgSetFinalize,
};

type msgSetArtworkAddParams = {
  value: MsgSetArtworkAdd,
};

type msgSetStoryAddParams = {
  value: MsgSetStoryAdd,
};

type msgBoosterPackBuyParams = {
  value: MsgBoosterPackBuy,
};

type msgSellOfferCreateParams = {
  value: MsgSellOfferCreate,
};

type msgSellOfferBuyParams = {
  value: MsgSellOfferBuy,
};

type msgSellOfferRemoveParams = {
  value: MsgSellOfferRemove,
};

type msgCardRaritySetParams = {
  value: MsgCardRaritySet,
};

type msgCouncilResponseCommitParams = {
  value: MsgCouncilResponseCommit,
};

type msgCouncilResponseRevealParams = {
  value: MsgCouncilResponseReveal,
};

type msgCouncilRestartParams = {
  value: MsgCouncilRestart,
};

type msgMatchConfirmParams = {
  value: MsgMatchConfirm,
};

type msgProfileCardSetParams = {
  value: MsgProfileCardSet,
};

type msgProfileWebsiteSetParams = {
  value: MsgProfileWebsiteSet,
};

type msgProfileBioSetParams = {
  value: MsgProfileBioSet,
};

type msgBoosterPackOpenParams = {
  value: MsgBoosterPackOpen,
};

type msgBoosterPackTransferParams = {
  value: MsgBoosterPackTransfer,
};

type msgSetStoryWriterSetParams = {
  value: MsgSetStoryWriterSet,
};

type msgSetArtistSetParams = {
  value: MsgSetArtistSet,
};

type msgCardVoteMultiParams = {
  value: MsgCardVoteMulti,
};

type msgMatchOpenParams = {
  value: MsgMatchOpen,
};

type msgSetNameSetParams = {
  value: MsgSetNameSet,
};

type msgProfileAliasSetParams = {
  value: MsgProfileAliasSet,
};

type msgEarlyAccessInviteParams = {
  value: MsgEarlyAccessInvite,
};

type msgZealyConnectParams = {
  value: MsgZealyConnect,
};

type msgEncounterCreateParams = {
  value: MsgEncounterCreate,
};

type msgEncounterDoParams = {
  value: MsgEncounterDo,
};

type msgEncounterCloseParams = {
  value: MsgEncounterClose,
};

type msgEarlyAccessDisinviteParams = {
  value: MsgEarlyAccessDisinvite,
};

type msgCardBanParams = {
  value: MsgCardBan,
};

type msgEarlyAccessGrantParams = {
  value: MsgEarlyAccessGrant,
};

type msgSetActivateParams = {
  value: MsgSetActivate,
};

type msgCardCopyrightClaimParams = {
  value: MsgCardCopyrightClaim,
};


export const registry = new Registry(msgTypes);

type Field = {
	name: string;
	type: unknown;
}
function getStructure(template) {
	const structure: {fields: Field[]} = { fields: [] }
	for (let [key, value] of Object.entries(template)) {
		let field = { name: key, type: typeof value }
		structure.fields.push(field)
	}
	return structure
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
	prefix: string
	signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => {

  return {
		
		async sendMsgUpdateParams({ value, fee, memo }: sendMsgUpdateParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParams({ value: MsgUpdateParams.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUserCreate({ value, fee, memo }: sendMsgUserCreateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUserCreate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUserCreate({ value: MsgUserCreate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUserCreate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCardSchemeBuy({ value, fee, memo }: sendMsgCardSchemeBuyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCardSchemeBuy: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCardSchemeBuy({ value: MsgCardSchemeBuy.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCardSchemeBuy: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCardSaveContent({ value, fee, memo }: sendMsgCardSaveContentParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCardSaveContent: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCardSaveContent({ value: MsgCardSaveContent.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCardSaveContent: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCardVote({ value, fee, memo }: sendMsgCardVoteParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCardVote: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCardVote({ value: MsgCardVote.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCardVote: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCardTransfer({ value, fee, memo }: sendMsgCardTransferParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCardTransfer: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCardTransfer({ value: MsgCardTransfer.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCardTransfer: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCardDonate({ value, fee, memo }: sendMsgCardDonateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCardDonate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCardDonate({ value: MsgCardDonate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCardDonate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCardArtworkAdd({ value, fee, memo }: sendMsgCardArtworkAddParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCardArtworkAdd: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCardArtworkAdd({ value: MsgCardArtworkAdd.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCardArtworkAdd: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCardArtistChange({ value, fee, memo }: sendMsgCardArtistChangeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCardArtistChange: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCardArtistChange({ value: MsgCardArtistChange.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCardArtistChange: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCouncilRegister({ value, fee, memo }: sendMsgCouncilRegisterParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCouncilRegister: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCouncilRegister({ value: MsgCouncilRegister.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCouncilRegister: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCouncilDeregister({ value, fee, memo }: sendMsgCouncilDeregisterParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCouncilDeregister: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCouncilDeregister({ value: MsgCouncilDeregister.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCouncilDeregister: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgMatchReport({ value, fee, memo }: sendMsgMatchReportParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgMatchReport: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgMatchReport({ value: MsgMatchReport.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgMatchReport: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCouncilCreate({ value, fee, memo }: sendMsgCouncilCreateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCouncilCreate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCouncilCreate({ value: MsgCouncilCreate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCouncilCreate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgMatchReporterAppoint({ value, fee, memo }: sendMsgMatchReporterAppointParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgMatchReporterAppoint: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgMatchReporterAppoint({ value: MsgMatchReporterAppoint.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgMatchReporterAppoint: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSetCreate({ value, fee, memo }: sendMsgSetCreateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSetCreate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSetCreate({ value: MsgSetCreate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSetCreate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSetCardAdd({ value, fee, memo }: sendMsgSetCardAddParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSetCardAdd: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSetCardAdd({ value: MsgSetCardAdd.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSetCardAdd: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSetCardRemove({ value, fee, memo }: sendMsgSetCardRemoveParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSetCardRemove: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSetCardRemove({ value: MsgSetCardRemove.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSetCardRemove: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSetContributorAdd({ value, fee, memo }: sendMsgSetContributorAddParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSetContributorAdd: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSetContributorAdd({ value: MsgSetContributorAdd.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSetContributorAdd: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSetContributorRemove({ value, fee, memo }: sendMsgSetContributorRemoveParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSetContributorRemove: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSetContributorRemove({ value: MsgSetContributorRemove.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSetContributorRemove: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSetFinalize({ value, fee, memo }: sendMsgSetFinalizeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSetFinalize: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSetFinalize({ value: MsgSetFinalize.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSetFinalize: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSetArtworkAdd({ value, fee, memo }: sendMsgSetArtworkAddParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSetArtworkAdd: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSetArtworkAdd({ value: MsgSetArtworkAdd.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSetArtworkAdd: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSetStoryAdd({ value, fee, memo }: sendMsgSetStoryAddParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSetStoryAdd: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSetStoryAdd({ value: MsgSetStoryAdd.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSetStoryAdd: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgBoosterPackBuy({ value, fee, memo }: sendMsgBoosterPackBuyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgBoosterPackBuy: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgBoosterPackBuy({ value: MsgBoosterPackBuy.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgBoosterPackBuy: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSellOfferCreate({ value, fee, memo }: sendMsgSellOfferCreateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSellOfferCreate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSellOfferCreate({ value: MsgSellOfferCreate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSellOfferCreate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSellOfferBuy({ value, fee, memo }: sendMsgSellOfferBuyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSellOfferBuy: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSellOfferBuy({ value: MsgSellOfferBuy.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSellOfferBuy: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSellOfferRemove({ value, fee, memo }: sendMsgSellOfferRemoveParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSellOfferRemove: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSellOfferRemove({ value: MsgSellOfferRemove.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSellOfferRemove: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCardRaritySet({ value, fee, memo }: sendMsgCardRaritySetParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCardRaritySet: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCardRaritySet({ value: MsgCardRaritySet.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCardRaritySet: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCouncilResponseCommit({ value, fee, memo }: sendMsgCouncilResponseCommitParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCouncilResponseCommit: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCouncilResponseCommit({ value: MsgCouncilResponseCommit.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCouncilResponseCommit: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCouncilResponseReveal({ value, fee, memo }: sendMsgCouncilResponseRevealParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCouncilResponseReveal: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCouncilResponseReveal({ value: MsgCouncilResponseReveal.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCouncilResponseReveal: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCouncilRestart({ value, fee, memo }: sendMsgCouncilRestartParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCouncilRestart: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCouncilRestart({ value: MsgCouncilRestart.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCouncilRestart: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgMatchConfirm({ value, fee, memo }: sendMsgMatchConfirmParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgMatchConfirm: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgMatchConfirm({ value: MsgMatchConfirm.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgMatchConfirm: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgProfileCardSet({ value, fee, memo }: sendMsgProfileCardSetParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgProfileCardSet: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgProfileCardSet({ value: MsgProfileCardSet.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgProfileCardSet: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgProfileWebsiteSet({ value, fee, memo }: sendMsgProfileWebsiteSetParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgProfileWebsiteSet: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgProfileWebsiteSet({ value: MsgProfileWebsiteSet.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgProfileWebsiteSet: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgProfileBioSet({ value, fee, memo }: sendMsgProfileBioSetParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgProfileBioSet: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgProfileBioSet({ value: MsgProfileBioSet.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgProfileBioSet: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgBoosterPackOpen({ value, fee, memo }: sendMsgBoosterPackOpenParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgBoosterPackOpen: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgBoosterPackOpen({ value: MsgBoosterPackOpen.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgBoosterPackOpen: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgBoosterPackTransfer({ value, fee, memo }: sendMsgBoosterPackTransferParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgBoosterPackTransfer: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgBoosterPackTransfer({ value: MsgBoosterPackTransfer.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgBoosterPackTransfer: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSetStoryWriterSet({ value, fee, memo }: sendMsgSetStoryWriterSetParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSetStoryWriterSet: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSetStoryWriterSet({ value: MsgSetStoryWriterSet.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSetStoryWriterSet: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSetArtistSet({ value, fee, memo }: sendMsgSetArtistSetParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSetArtistSet: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSetArtistSet({ value: MsgSetArtistSet.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSetArtistSet: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCardVoteMulti({ value, fee, memo }: sendMsgCardVoteMultiParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCardVoteMulti: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCardVoteMulti({ value: MsgCardVoteMulti.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCardVoteMulti: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgMatchOpen({ value, fee, memo }: sendMsgMatchOpenParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgMatchOpen: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgMatchOpen({ value: MsgMatchOpen.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgMatchOpen: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSetNameSet({ value, fee, memo }: sendMsgSetNameSetParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSetNameSet: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSetNameSet({ value: MsgSetNameSet.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSetNameSet: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgProfileAliasSet({ value, fee, memo }: sendMsgProfileAliasSetParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgProfileAliasSet: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgProfileAliasSet({ value: MsgProfileAliasSet.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgProfileAliasSet: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgEarlyAccessInvite({ value, fee, memo }: sendMsgEarlyAccessInviteParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgEarlyAccessInvite: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgEarlyAccessInvite({ value: MsgEarlyAccessInvite.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgEarlyAccessInvite: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgZealyConnect({ value, fee, memo }: sendMsgZealyConnectParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgZealyConnect: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgZealyConnect({ value: MsgZealyConnect.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgZealyConnect: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgEncounterCreate({ value, fee, memo }: sendMsgEncounterCreateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgEncounterCreate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgEncounterCreate({ value: MsgEncounterCreate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgEncounterCreate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgEncounterDo({ value, fee, memo }: sendMsgEncounterDoParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgEncounterDo: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgEncounterDo({ value: MsgEncounterDo.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgEncounterDo: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgEncounterClose({ value, fee, memo }: sendMsgEncounterCloseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgEncounterClose: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgEncounterClose({ value: MsgEncounterClose.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgEncounterClose: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgEarlyAccessDisinvite({ value, fee, memo }: sendMsgEarlyAccessDisinviteParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgEarlyAccessDisinvite: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgEarlyAccessDisinvite({ value: MsgEarlyAccessDisinvite.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgEarlyAccessDisinvite: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCardBan({ value, fee, memo }: sendMsgCardBanParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCardBan: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCardBan({ value: MsgCardBan.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCardBan: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgEarlyAccessGrant({ value, fee, memo }: sendMsgEarlyAccessGrantParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgEarlyAccessGrant: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgEarlyAccessGrant({ value: MsgEarlyAccessGrant.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgEarlyAccessGrant: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSetActivate({ value, fee, memo }: sendMsgSetActivateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSetActivate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSetActivate({ value: MsgSetActivate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSetActivate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCardCopyrightClaim({ value, fee, memo }: sendMsgCardCopyrightClaimParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCardCopyrightClaim: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCardCopyrightClaim({ value: MsgCardCopyrightClaim.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCardCopyrightClaim: Could not broadcast Tx: '+ e.message)
			}
		},
		
		
		msgUpdateParams({ value }: msgUpdateParamsParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgUpdateParams", value: MsgUpdateParams.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message)
			}
		},
		
		msgUserCreate({ value }: msgUserCreateParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgUserCreate", value: MsgUserCreate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUserCreate: Could not create message: ' + e.message)
			}
		},
		
		msgCardSchemeBuy({ value }: msgCardSchemeBuyParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgCardSchemeBuy", value: MsgCardSchemeBuy.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCardSchemeBuy: Could not create message: ' + e.message)
			}
		},
		
		msgCardSaveContent({ value }: msgCardSaveContentParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgCardSaveContent", value: MsgCardSaveContent.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCardSaveContent: Could not create message: ' + e.message)
			}
		},
		
		msgCardVote({ value }: msgCardVoteParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgCardVote", value: MsgCardVote.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCardVote: Could not create message: ' + e.message)
			}
		},
		
		msgCardTransfer({ value }: msgCardTransferParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgCardTransfer", value: MsgCardTransfer.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCardTransfer: Could not create message: ' + e.message)
			}
		},
		
		msgCardDonate({ value }: msgCardDonateParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgCardDonate", value: MsgCardDonate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCardDonate: Could not create message: ' + e.message)
			}
		},
		
		msgCardArtworkAdd({ value }: msgCardArtworkAddParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgCardArtworkAdd", value: MsgCardArtworkAdd.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCardArtworkAdd: Could not create message: ' + e.message)
			}
		},
		
		msgCardArtistChange({ value }: msgCardArtistChangeParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgCardArtistChange", value: MsgCardArtistChange.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCardArtistChange: Could not create message: ' + e.message)
			}
		},
		
		msgCouncilRegister({ value }: msgCouncilRegisterParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgCouncilRegister", value: MsgCouncilRegister.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCouncilRegister: Could not create message: ' + e.message)
			}
		},
		
		msgCouncilDeregister({ value }: msgCouncilDeregisterParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgCouncilDeregister", value: MsgCouncilDeregister.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCouncilDeregister: Could not create message: ' + e.message)
			}
		},
		
		msgMatchReport({ value }: msgMatchReportParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgMatchReport", value: MsgMatchReport.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgMatchReport: Could not create message: ' + e.message)
			}
		},
		
		msgCouncilCreate({ value }: msgCouncilCreateParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgCouncilCreate", value: MsgCouncilCreate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCouncilCreate: Could not create message: ' + e.message)
			}
		},
		
		msgMatchReporterAppoint({ value }: msgMatchReporterAppointParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgMatchReporterAppoint", value: MsgMatchReporterAppoint.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgMatchReporterAppoint: Could not create message: ' + e.message)
			}
		},
		
		msgSetCreate({ value }: msgSetCreateParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgSetCreate", value: MsgSetCreate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSetCreate: Could not create message: ' + e.message)
			}
		},
		
		msgSetCardAdd({ value }: msgSetCardAddParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgSetCardAdd", value: MsgSetCardAdd.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSetCardAdd: Could not create message: ' + e.message)
			}
		},
		
		msgSetCardRemove({ value }: msgSetCardRemoveParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgSetCardRemove", value: MsgSetCardRemove.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSetCardRemove: Could not create message: ' + e.message)
			}
		},
		
		msgSetContributorAdd({ value }: msgSetContributorAddParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgSetContributorAdd", value: MsgSetContributorAdd.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSetContributorAdd: Could not create message: ' + e.message)
			}
		},
		
		msgSetContributorRemove({ value }: msgSetContributorRemoveParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgSetContributorRemove", value: MsgSetContributorRemove.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSetContributorRemove: Could not create message: ' + e.message)
			}
		},
		
		msgSetFinalize({ value }: msgSetFinalizeParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgSetFinalize", value: MsgSetFinalize.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSetFinalize: Could not create message: ' + e.message)
			}
		},
		
		msgSetArtworkAdd({ value }: msgSetArtworkAddParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgSetArtworkAdd", value: MsgSetArtworkAdd.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSetArtworkAdd: Could not create message: ' + e.message)
			}
		},
		
		msgSetStoryAdd({ value }: msgSetStoryAddParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgSetStoryAdd", value: MsgSetStoryAdd.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSetStoryAdd: Could not create message: ' + e.message)
			}
		},
		
		msgBoosterPackBuy({ value }: msgBoosterPackBuyParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgBoosterPackBuy", value: MsgBoosterPackBuy.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgBoosterPackBuy: Could not create message: ' + e.message)
			}
		},
		
		msgSellOfferCreate({ value }: msgSellOfferCreateParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgSellOfferCreate", value: MsgSellOfferCreate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSellOfferCreate: Could not create message: ' + e.message)
			}
		},
		
		msgSellOfferBuy({ value }: msgSellOfferBuyParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgSellOfferBuy", value: MsgSellOfferBuy.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSellOfferBuy: Could not create message: ' + e.message)
			}
		},
		
		msgSellOfferRemove({ value }: msgSellOfferRemoveParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgSellOfferRemove", value: MsgSellOfferRemove.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSellOfferRemove: Could not create message: ' + e.message)
			}
		},
		
		msgCardRaritySet({ value }: msgCardRaritySetParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgCardRaritySet", value: MsgCardRaritySet.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCardRaritySet: Could not create message: ' + e.message)
			}
		},
		
		msgCouncilResponseCommit({ value }: msgCouncilResponseCommitParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgCouncilResponseCommit", value: MsgCouncilResponseCommit.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCouncilResponseCommit: Could not create message: ' + e.message)
			}
		},
		
		msgCouncilResponseReveal({ value }: msgCouncilResponseRevealParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgCouncilResponseReveal", value: MsgCouncilResponseReveal.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCouncilResponseReveal: Could not create message: ' + e.message)
			}
		},
		
		msgCouncilRestart({ value }: msgCouncilRestartParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgCouncilRestart", value: MsgCouncilRestart.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCouncilRestart: Could not create message: ' + e.message)
			}
		},
		
		msgMatchConfirm({ value }: msgMatchConfirmParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgMatchConfirm", value: MsgMatchConfirm.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgMatchConfirm: Could not create message: ' + e.message)
			}
		},
		
		msgProfileCardSet({ value }: msgProfileCardSetParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgProfileCardSet", value: MsgProfileCardSet.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgProfileCardSet: Could not create message: ' + e.message)
			}
		},
		
		msgProfileWebsiteSet({ value }: msgProfileWebsiteSetParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgProfileWebsiteSet", value: MsgProfileWebsiteSet.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgProfileWebsiteSet: Could not create message: ' + e.message)
			}
		},
		
		msgProfileBioSet({ value }: msgProfileBioSetParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgProfileBioSet", value: MsgProfileBioSet.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgProfileBioSet: Could not create message: ' + e.message)
			}
		},
		
		msgBoosterPackOpen({ value }: msgBoosterPackOpenParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgBoosterPackOpen", value: MsgBoosterPackOpen.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgBoosterPackOpen: Could not create message: ' + e.message)
			}
		},
		
		msgBoosterPackTransfer({ value }: msgBoosterPackTransferParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgBoosterPackTransfer", value: MsgBoosterPackTransfer.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgBoosterPackTransfer: Could not create message: ' + e.message)
			}
		},
		
		msgSetStoryWriterSet({ value }: msgSetStoryWriterSetParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgSetStoryWriterSet", value: MsgSetStoryWriterSet.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSetStoryWriterSet: Could not create message: ' + e.message)
			}
		},
		
		msgSetArtistSet({ value }: msgSetArtistSetParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgSetArtistSet", value: MsgSetArtistSet.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSetArtistSet: Could not create message: ' + e.message)
			}
		},
		
		msgCardVoteMulti({ value }: msgCardVoteMultiParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgCardVoteMulti", value: MsgCardVoteMulti.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCardVoteMulti: Could not create message: ' + e.message)
			}
		},
		
		msgMatchOpen({ value }: msgMatchOpenParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgMatchOpen", value: MsgMatchOpen.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgMatchOpen: Could not create message: ' + e.message)
			}
		},
		
		msgSetNameSet({ value }: msgSetNameSetParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgSetNameSet", value: MsgSetNameSet.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSetNameSet: Could not create message: ' + e.message)
			}
		},
		
		msgProfileAliasSet({ value }: msgProfileAliasSetParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgProfileAliasSet", value: MsgProfileAliasSet.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgProfileAliasSet: Could not create message: ' + e.message)
			}
		},
		
		msgEarlyAccessInvite({ value }: msgEarlyAccessInviteParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgEarlyAccessInvite", value: MsgEarlyAccessInvite.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgEarlyAccessInvite: Could not create message: ' + e.message)
			}
		},
		
		msgZealyConnect({ value }: msgZealyConnectParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgZealyConnect", value: MsgZealyConnect.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgZealyConnect: Could not create message: ' + e.message)
			}
		},
		
		msgEncounterCreate({ value }: msgEncounterCreateParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgEncounterCreate", value: MsgEncounterCreate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgEncounterCreate: Could not create message: ' + e.message)
			}
		},
		
		msgEncounterDo({ value }: msgEncounterDoParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgEncounterDo", value: MsgEncounterDo.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgEncounterDo: Could not create message: ' + e.message)
			}
		},
		
		msgEncounterClose({ value }: msgEncounterCloseParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgEncounterClose", value: MsgEncounterClose.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgEncounterClose: Could not create message: ' + e.message)
			}
		},
		
		msgEarlyAccessDisinvite({ value }: msgEarlyAccessDisinviteParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgEarlyAccessDisinvite", value: MsgEarlyAccessDisinvite.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgEarlyAccessDisinvite: Could not create message: ' + e.message)
			}
		},
		
		msgCardBan({ value }: msgCardBanParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgCardBan", value: MsgCardBan.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCardBan: Could not create message: ' + e.message)
			}
		},
		
		msgEarlyAccessGrant({ value }: msgEarlyAccessGrantParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgEarlyAccessGrant", value: MsgEarlyAccessGrant.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgEarlyAccessGrant: Could not create message: ' + e.message)
			}
		},
		
		msgSetActivate({ value }: msgSetActivateParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgSetActivate", value: MsgSetActivate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSetActivate: Could not create message: ' + e.message)
			}
		},
		
		msgCardCopyrightClaim({ value }: msgCardCopyrightClaimParams): EncodeObject {
			try {
				return { typeUrl: "/cardchain.cardchain.MsgCardCopyrightClaim", value: MsgCardCopyrightClaim.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCardCopyrightClaim: Could not create message: ' + e.message)
			}
		},
		
	}
};

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr: addr }: QueryClientOptions = { addr: "http://localhost:1317" }) => {
  return new Api({ baseURL: addr });
};

class SDKModule {
	public query: ReturnType<typeof queryClient>;
	public tx: ReturnType<typeof txClient>;
	public structure: Record<string,unknown>;
	public registry: Array<[string, GeneratedType]> = [];

	constructor(client: IgniteClient) {		
	
		this.query = queryClient({ addr: client.env.apiURL });		
		this.updateTX(client);
		this.structure =  {
						Card: getStructure(typeCard.fromPartial({})),
						TimeStamp: getStructure(typeTimeStamp.fromPartial({})),
						CardContent: getStructure(typeCardContent.fromPartial({})),
						CardWithImage: getStructure(typeCardWithImage.fromPartial({})),
						Council: getStructure(typeCouncil.fromPartial({})),
						WrapClearResponse: getStructure(typeWrapClearResponse.fromPartial({})),
						WrapHashResponse: getStructure(typeWrapHashResponse.fromPartial({})),
						Encounter: getStructure(typeEncounter.fromPartial({})),
						EncounterWithImage: getStructure(typeEncounterWithImage.fromPartial({})),
						Image: getStructure(typeImage.fromPartial({})),
						Match: getStructure(typeMatch.fromPartial({})),
						MatchPlayer: getStructure(typeMatchPlayer.fromPartial({})),
						Params: getStructure(typeParams.fromPartial({})),
						RunningAverage: getStructure(typeRunningAverage.fromPartial({})),
						SellOffer: getStructure(typeSellOffer.fromPartial({})),
						Server: getStructure(typeServer.fromPartial({})),
						Set: getStructure(typeSet.fromPartial({})),
						InnerRarities: getStructure(typeInnerRarities.fromPartial({})),
						AddrWithQuantity: getStructure(typeAddrWithQuantity.fromPartial({})),
						SetWithArtwork: getStructure(typeSetWithArtwork.fromPartial({})),
						User: getStructure(typeUser.fromPartial({})),
						EarlyAccess: getStructure(typeEarlyAccess.fromPartial({})),
						BoosterPack: getStructure(typeBoosterPack.fromPartial({})),
						AirDrops: getStructure(typeAirDrops.fromPartial({})),
						VotingResult: getStructure(typeVotingResult.fromPartial({})),
						SingleVote: getStructure(typeSingleVote.fromPartial({})),
						VotingResults: getStructure(typeVotingResults.fromPartial({})),
						Zealy: getStructure(typeZealy.fromPartial({})),
						
		};
		client.on('signer-changed',(signer) => {			
		 this.updateTX(client);
		})
	}
	updateTX(client: IgniteClient) {
    const methods = txClient({
        signer: client.signer,
        addr: client.env.rpcURL,
        prefix: client.env.prefix ?? "cosmos",
    })
	
    this.tx = methods;
    for (let m in methods) {
        this.tx[m] = methods[m].bind(this.tx);
    }
	}
};

const IgntModule = (test: IgniteClient) => {
	return {
		module: {
			CardchainCardchain: new SDKModule(test)
		},
		registry: msgTypes
  }
}
export default IgntModule;